<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wind-mills&#39;s blog</title>
  
  <subtitle>xxx</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-02T08:46:52.958Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wind-mills</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>elasticsearch移除type</title>
    <link href="http://yoursite.com/2019/08/30/es/Elasticsearch%20%E7%A7%BB%E9%99%A4%20type/"/>
    <id>http://yoursite.com/2019/08/30/es/Elasticsearch 移除 type/</id>
    <published>2019-08-29T16:00:00.000Z</published>
    <updated>2019-09-02T08:46:52.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --><h1 id="when"><a href="#when" class="headerlink" title="when"></a>when</h1><h2 id="1-映射类型的移除计划"><a href="#1-映射类型的移除计划" class="headerlink" title="1.映射类型的移除计划"></a>1.映射类型的移除计划</h2><p>对于用户来说这是一个大的变化，所以我们尽可能将这个过程变得平滑。这次变更的计划如下：</p><h3 id="1-1-Elasticsearch-5-6-0"><a href="#1-1-Elasticsearch-5-6-0" class="headerlink" title="1.1.Elasticsearch 5.6.0"></a>1.1.Elasticsearch 5.6.0</h3><p>在一个索引上设<code>index.mapping.single_type:true</code>会启用单索引-单一类型的行为，而这种行为在6.0中是强制的。</p><p>在5.6中创建的索引可以使用创建文档间父子关系的新的join字段。</p><h3 id="1-2-Elasticsearch-6-x"><a href="#1-2-Elasticsearch-6-x" class="headerlink" title="1.2.Elasticsearch 6.x"></a>1.2.Elasticsearch 6.x</h3><p><code>5.x</code>中创建的索引可以在<code>6.x</code>中正常工作</p><p><code>6.x</code>中创建的索引只允许单个索引中存在单一的类型。任意的名字都可以作为类型，但是只能有一个。</p><p><code>_type</code>名不再与_id组合生成_uid字段。_uid字段变成仅仅是_id字段的别名。</p><p>新创建的索引不再支持旧风格的父子关系，而应该使用join字段。</p><p><code>_default_</code>映射类型被标记为不推荐使用。</p><h3 id="1-3-Elasticsearch-7-x"><a href="#1-3-Elasticsearch-7-x" class="headerlink" title="1.3.Elasticsearch 7.x"></a>1.3.Elasticsearch 7.x</h3><p>URL中的type参数为可选。比如，索引一个文档不再要求提供文档类型。</p><p><code>GET|PUT_mapping</code> API支持一个查询字符串参数（include_type_name），通过这个参数来指定请求体是否应该包含一个类型名的层。默认是true。7.x中没有显式指定类型的索引将会使用默认的_doc类型名。</p><p><code>_default_</code>映射类型移除。</p><h3 id="1-4-Elasticsearch-8-x"><a href="#1-4-Elasticsearch-8-x" class="headerlink" title="1.4.Elasticsearch 8.x"></a>1.4.Elasticsearch 8.x</h3><p>不再支持URL中的type参数。</p><p><code>include_type_name</code>参数默认为false。</p><h3 id="1-5-Elasticsearch-9-x"><a href="#1-5-Elasticsearch-9-x" class="headerlink" title="1.5.Elasticsearch 9.x"></a>1.5.Elasticsearch 9.x</h3><p><code>include_type_name</code>参数移除。</p><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><h2 id="2-为什么移除"><a href="#2-为什么移除" class="headerlink" title="2.为什么移除"></a>2.为什么移除</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/removal-of-types.html" target="_blank" rel="noopener">官方解释</a></p><p>起初，我们说”索引”和关系数据库的“库”是相似的，“类型”和“表”是对等的</p><p><strong>这是一个不正确的对比，导致了不正确的假设。</strong><br>在关系型数据库里,”表”是相互独立的,一个“表”里的列和另外一个“表”的同名列没有关系，互不影响。但在类型里字段不是这样的</p><p>在一个Elasticsearch索引里，所有不同类型的同名字段内部使用的是同一个lucene字段存储。也就是说，上面例子中，user类型的user_name字段和tweet类型的user_name字段是存储在一个字段里的，两个类型里的user_name必须有一样的映射(字段定义)</p><p>这可能导致一些问题，例如你希望同一个索引中”deleted”字段在一个类型里是存储日期值，在另外一个类型里存储布尔值</p><p>最后,在同一个索引中，存储仅有小部分字段相同或者全部字段都不相同的文档，会导致数据稀疏，影响Lucene有效压缩数据的能力。</p><p>因为这些原因，决定从Elasticsearch中移除类型的概念。</p><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><h2 id="3-后续使用"><a href="#3-后续使用" class="headerlink" title="3.后续使用"></a>3.后续使用</h2><h3 id="3-1-映射类型的可选替代方案"><a href="#3-1-映射类型的可选替代方案" class="headerlink" title="3.1.映射类型的可选替代方案"></a>3.1.映射类型的可选替代方案</h3><blockquote><p>每种文档类型一个索引</p></blockquote><p>第一种选择就是每个文档类型对应一个索引。你可以不将tweets和users存储于同一个索引，而将它们分别存储于tweets索引和users索引中。索引之间是完全相互独立的，不同索引中的（同名的）字段类型也就不会产生冲突了。</p><blockquote><p>这种方式有两个好处：</p></blockquote><ul><li>数据更倾向于密集（而不是稀疏），这样就能获益于Lucene的压缩技术。</li><li>因为同一个索引中的所有的文档代表同一种实体，用于为全文搜索打分的条件统计会更精确。</li></ul><p>每个索引可以依据其可能的文档存储量级来设置相关的配置：可以对users使用较少的主分片，同时对tweets使用较大数量的主分片。</p><blockquote><p>自定义类型字段</p></blockquote><p>当然，一个集群中可以创建的主分片的数量是有限制的，所以你可能不想为一个只有几千个文档的集合去浪费一整个分片。这种情况下你可以使用你自己定义的type字段，它看起来和原来的_type工作机制类似。</p><p>我们使用的user/tweet例子。原来的工作流程可能像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET twitter/user,tweet/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;user_name&quot;: &quot;kimchy&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PUT twitter</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;user&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;,</span><br><span class="line">        &quot;user_name&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;,</span><br><span class="line">        &quot;email&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tweet&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;,</span><br><span class="line">        &quot;user_name&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;,</span><br><span class="line">        &quot;tweeted_at&quot;: &#123; &quot;type&quot;: &quot;date&quot; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT twitter/user/kimchy</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Shay Banon&quot;,</span><br><span class="line">  &quot;user_name&quot;: &quot;kimchy&quot;,</span><br><span class="line">  &quot;email&quot;: &quot;shay@kimchy.com&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT twitter/tweet/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;user_name&quot;: &quot;kimchy&quot;,</span><br><span class="line">  &quot;tweeted_at&quot;: &quot;2019-4-24T09:00:00Z&quot;,</span><br><span class="line">  &quot;content&quot;: &quot;Types are going away&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET twitter/tweet/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;user_name&quot;: &quot;kimchy&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>你可以通过自定义的type字段实现同样的目的：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">PUT twitter</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;doc&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, </span><br><span class="line">        &quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;,</span><br><span class="line">        &quot;user_name&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;,</span><br><span class="line">        &quot;email&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;,</span><br><span class="line">        &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;,</span><br><span class="line">        &quot;tweeted_at&quot;: &#123; &quot;type&quot;: &quot;date&quot; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT twitter/doc/user-kimchy</span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;user&quot;, </span><br><span class="line">  &quot;name&quot;: &quot;Shay Banon&quot;,</span><br><span class="line">  &quot;user_name&quot;: &quot;kimchy&quot;,</span><br><span class="line">  &quot;email&quot;: &quot;shay@kimchy.com&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT twitter/doc/tweet-1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;tweet&quot;, </span><br><span class="line">  &quot;user_name&quot;: &quot;kimchy&quot;,</span><br><span class="line">  &quot;tweeted_at&quot;: &quot;2019-4-24T09:00:00Z&quot;,</span><br><span class="line">  &quot;content&quot;: &quot;Types are going away&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET twitter/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;user_name&quot;: &quot;kimchy&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;tweet&quot; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在没有映射类型的情况下实现父子关系</p></blockquote><p>先前，我们通过将一个映射类型指定为父，另一个或多个映射类型为子来表示父子关系。在没有类型的情况下，我们就不能使用这种语法了。父子关系的特征会向之前那样工作，不同之处在于文档之间这种关系的表示方式变成了使用新的join字段。</p><h3 id="3-2-新姿势"><a href="#3-2-新姿势" class="headerlink" title="3.2.新姿势"></a>3.2.新姿势</h3><p>随着 7.0 版本的即将发布，type 的移除也是越来越近了，在 6.0 的时候，已经默认只能支持一个索引一个 type 了，7.0 版本新增了一个参数 include_type_name ，即让所有的 API 是 type 相关的，这个参数在 7.0 默认是 true，不过在 8.0 的时候，会默认改成 false，也就是不包含 type 信息了，这个是 type 用于移除的一个开关。</p><p>看看最新的使用姿势吧，当 include_type_name 参数设置成 false 后：</p><ul><li>索引操作：<code>PUT {index}/{type}/{id}</code>需要修改成<code>PUT {index}/_doc/{id}</code></li><li>Mapping 操作：<code>PUT {index}/{type}/_mapping</code> 则变成 <code>PUT {index}/_mapping</code></li><li>所有增删改查搜索操作返回结果里面的关键字 <code>_type</code> 都将被移除</li><li>父子关系使用 <code>join</code> 字段来构建</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#创建索引</span><br><span class="line">PUT twitter</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;_doc&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, </span><br><span class="line">        &quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;,</span><br><span class="line">        &quot;user_name&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;,</span><br><span class="line">        &quot;email&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;,</span><br><span class="line">        &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;,</span><br><span class="line">        &quot;tweeted_at&quot;: &#123; &quot;type&quot;: &quot;date&quot; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#修改索引</span><br><span class="line">PUT twitter/_doc/user-kimchy</span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;user&quot;, </span><br><span class="line">  &quot;name&quot;: &quot;Shay Banon&quot;,</span><br><span class="line">  &quot;user_name&quot;: &quot;kimchy&quot;,</span><br><span class="line">  &quot;email&quot;: &quot;shay@kimchy.com&quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#搜索</span><br><span class="line">GET twitter/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;user_name&quot;: &quot;kimchy&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;tweet&quot; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#重建索引</span><br><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;twitter&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;new_twitter&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;when&quot;&gt;&lt;a href=&quot;#when&quot; class=&quot;headerlink&quot; title=&quot;when&quot;&gt;&lt;/a&gt;when&lt;/h1&gt;
      
    
    </summary>
    
      <category term="elasticsearch" scheme="http://yoursite.com/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="http://yoursite.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Head插件安装</title>
    <link href="http://yoursite.com/2019/08/30/es/Head(%E7%B1%BB%E4%BC%BC%E4%BA%8Emysql%E7%9A%84Navicat)/"/>
    <id>http://yoursite.com/2019/08/30/es/Head(类似于mysql的Navicat)/</id>
    <published>2019-08-29T16:00:00.000Z</published>
    <updated>2019-09-02T08:51:29.130Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --><h1 id="1-安装环境"><a href="#1-安装环境" class="headerlink" title="1.安装环境"></a>1.安装环境</h1><p>Node.js 10.15.3</p><h1 id="2-安装步骤："><a href="#2-安装步骤：" class="headerlink" title="2.安装步骤："></a>2.安装步骤：</h1><h2 id="2-1-Node-js环境安装"><a href="#2-1-Node-js环境安装" class="headerlink" title="2.1.Node.js环境安装"></a>2.1.Node.js环境安装</h2><p>head插件要求Node.js环境，并且Node.js的版本 大于等于 6.0。</p><p>首先，在官网下载Node.js。这里，我直接下载最新版 Node.js 10.15.3。下载地址：<a href="https://nodejs.org/en/download/。" target="_blank" rel="noopener">https://nodejs.org/en/download/。</a><br>选择Linux Binaries (x64)，点击下载、解压。解压完成后，然后配置一下环境变量。下面给出我的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NODE_HOME=/home/tom/data/node-v10.15.3-linux-x64</span><br><span class="line">export PATH=$NODE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>配置好后，执行命令 source /etc/profile 使上面的配置生效。然后执行 npm -v，看到输出 6.4.1。则咱们的Node.js环境安装成功。</p><h2 id="2-2-head插件安装"><a href="#2-2-head插件安装" class="headerlink" title="2.2.head插件安装"></a>2.2.head插件安装</h2><p>首先，在GitHub上找到head插件，地址：<a href="https://github.com/mobz/elasticsearch-head。将其下载/克隆到本地。" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head。将其下载/克隆到本地。</a></p><p>下载完成后，进入 elasticsearch-head的目录下，按顺序执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装插件；由于需要下载一些数据，所以可能会比较慢。</span><br><span class="line">npm install</span><br><span class="line"># 启动插件；如果需要后台启动，可以使用 nohup，具体用法请自行百度</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure><p>按道理，执行上面的命令后，head 插件应该成功安装，并且正常启动。启动后，我们可以通过 localhost:9100 进行访问。但是，我在安装过程中，碰到了以下问题，下面记录下来，并和大家分享，希望能帮到大家。</p><h2 id="2-3-问题解决"><a href="#2-3-问题解决" class="headerlink" title="2.3.问题解决"></a>2.3.问题解决</h2><h3 id="2-3-1-问题一"><a href="#2-3-1-问题一" class="headerlink" title="2.3.1.问题一"></a>2.3.1.问题一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! Error: EACCES: permission denied, access &apos;/home/tom/data/elasticsearch-head-master/node_modules&apos;</span><br></pre></td></tr></table></figure><p>显而易见，这是目录访问权限问题。我的解决办法是：切换到 root 用户，再执行 npm install 进行安装。</p><h3 id="2-3-2-问题二"><a href="#2-3-2-问题二" class="headerlink" title="2.3.2.问题二"></a>2.3.2.问题二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error extracting archive</span><br><span class="line">tar (child): bzip2：无法 exec: 没有那个文件或目录</span><br></pre></td></tr></table></figure><p>这个问题是因为系统中缺少 bzip2 包，直接执行下面命令安装即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y bzip2</span><br></pre></td></tr></table></figure><h3 id="2-3-3-问题三"><a href="#2-3-3-问题三" class="headerlink" title="2.3.3.问题三"></a>2.3.3.问题三</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! phantomjs-prebuilt@2.1.16 install: `node install.js`</span><br></pre></td></tr></table></figure><p>这个我在github的一个issue下找到了答案，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install phantomjs-prebuilt@2.1.16 --ignore-scripts</span><br></pre></td></tr></table></figure><p>这样，我们就安装好了 <code>phantomjs-prebuilt@2.1.16</code>，再执行 <code>npm install</code> 即可。</p><p>到这里时，head插件安装的问题全部都解决了，启动head插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br><span class="line">localhost:9100</span><br></pre></td></tr></table></figure><h3 id="2-3-4-问题四"><a href="#2-3-4-问题四" class="headerlink" title="2.3.4.问题四"></a>2.3.4.问题四</h3><blockquote><p>无法连接es</p></blockquote><p>ES和head插件实际上属于两个不同的进程，这里存在一个跨域问题。要解决这个问题，需要首先关闭Elasticsearch，在elasticsearch.yml文件后添加两行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure><p>然后，重新启动ES，刷新 head 插件页面，即可看到现在head插件已经正确查找到了我们的启动那个ES节点</p><p>至此，我们的Elasticsearch-head插件就安装成功了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;1-安装环境&quot;&gt;&lt;a href=&quot;#1-安装环境&quot; class=&quot;headerlink&quot; title=&quot;1.安装环境&quot;&gt;&lt;/a&gt;1.安
      
    
    </summary>
    
      <category term="elasticsearch" scheme="http://yoursite.com/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch插件" scheme="http://yoursite.com/tags/elasticsearch%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>搭建cerebro监控</title>
    <link href="http://yoursite.com/2019/08/30/es/Centos7%20%E6%90%AD%E5%BB%BACerebro%20Elasticsearch%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2019/08/30/es/Centos7 搭建Cerebro Elasticsearch监控/</id>
    <published>2019-08-29T16:00:00.000Z</published>
    <updated>2019-09-02T08:51:17.749Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --><h1 id="Cerebro-Elasticsearch"><a href="#Cerebro-Elasticsearch" class="headerlink" title="Cerebro Elasticsearch"></a>Cerebro Elasticsearch</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>cerebro是一个开源(MIT许可)elasticsearch web管理工具，使用Scala、Play Framework、AngularJS和Bootstrap构建。cerebro的运行需要java1.8及以上版本。（对比head插件，比head页面美观，也方便使用）</p><p>项目Github主页 ： <a href="https://github.com/lmenezes/cerebro" target="_blank" rel="noopener">https://github.com/lmenezes/cerebro</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/lmenezes/cerebro/releases/download/v0.8.1/cerebro-0.8.1.tgz</span><br><span class="line">tar -zxvf cerebro-0.8.1.tgz</span><br></pre></td></tr></table></figure><blockquote><p>配置：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">es = &#123;</span><br><span class="line">  gzip = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Authentication</span><br><span class="line">auth = &#123;</span><br><span class="line">type: basic</span><br><span class="line">    settings: &#123;</span><br><span class="line">      username = &quot;wind&quot;</span><br><span class="line">      password = &quot;xxxxx&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># A list of known hosts</span><br><span class="line">hosts = [</span><br><span class="line">  &#123;</span><br><span class="line">    host = &quot;http://localhost:9200&quot;</span><br><span class="line">    name = &quot;WIND-ES&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>启动 ：<br>./bin/cerebro</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 访问,9000端口:</span><br></pre></td></tr></table></figure><p><a href="http://xxx.xxx:9000/" target="_blank" rel="noopener">http://xxx.xxx:9000/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">默认端口为9000，若需要修改端口</span><br></pre></td></tr></table></figure><p>tee -a /etc/systemd/system/cerebro.service &lt;&lt; ‘EOF’<br>http = {<br>port = “9000”<br>address = “192.168.1.144”<br>}<br>EOF<br>```<br>port<br>暴露的端口<br>address<br>默认为0.0.0.0，设置为0.0.0.0表示对该主机所有网卡开放</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Cerebro-Elasticsearch&quot;&gt;&lt;a href=&quot;#Cerebro-Elasticsearch&quot; class=&quot;head
      
    
    </summary>
    
      <category term="elasticsearch" scheme="http://yoursite.com/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch插件" scheme="http://yoursite.com/tags/elasticsearch%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch安装</title>
    <link href="http://yoursite.com/2019/08/30/es/elasticsearch%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/08/30/es/elasticsearch安装配置/</id>
    <published>2019-08-29T16:00:00.000Z</published>
    <updated>2019-09-02T08:44:10.370Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --><h1 id="1-安装步骤"><a href="#1-安装步骤" class="headerlink" title="1.安装步骤"></a>1.安装步骤</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><p>从官网下载linux版本的elasticsearch安装程序，<a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/elasticsearch</a> （最好直接通过迅雷工具下载，普通下载太慢了）目前的版本是7.x的：elasticsearch-7.0.1-linux-x86_64.tar.gz</p><h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h2><p>centos服务器安装ftp软件（winSCP等），通过ftp软件把<code>elasticsearch-7.0.1-linux-x86_64.tar.gz</code>上传到服务器的<code>opt/mysoft</code>目录下。</p><h2 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h2><p><code>tar -zxvf elasticsearch-7.0.1-linux-x86_64.tar.gz</code></p><p>解压到当前目录下，</p><p><code>mv elasticsearch-7.0.1/ elasticsearch</code></p><p>重命名为elasticsearch</p><h2 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h2><p>通过命令：</p><p><code>sh /opt/mysoft/elasticsearch/bin/elasticsearch</code></p><p>启动ElasticSearch。启动后会因为权限可能抛出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">    1.添加用户：useradd elastic</span><br><span class="line">    2.给用户授权：chown -R elastic:elastic /opt/mysoft/elasticserch/</span><br><span class="line">    3.切换用户：su elastic</span><br><span class="line">    4.通过命令重写启动服务：sh /opt/mysoft/elasticsearch/bin/elasticsearch -d</span><br><span class="line">    5.输入：curl http://localhost:9200</span><br></pre></td></tr></table></figure><h2 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h2><p><code>vi /opt/mysoft/elasticserch/config/elasticsearch.yml</code></p><p>修改network配置本机的ip地址和端口号：</p><p><code>network.host: 192.168.248.100</code></p><p><code>http.port: 9200</code></p><p>修改之后可能会出现问题：</p><hr><h3 id="p1"><a href="#p1" class="headerlink" title="p1"></a>p1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN [o.e.b.JNANatives ] unable to install syscall filter</span><br></pre></td></tr></table></figure><p>使用新的linux版本就没问题了</p><hr><h3 id="p2"><a href="#p2" class="headerlink" title="p2"></a>p2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR: bootstrap checks failed</span><br><span class="line">max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536]</span><br><span class="line">max number of threads [1024] for user [lishang] likely too low, increase to at least [2048]</span><br></pre></td></tr></table></figure><p>解决：切换到root用户，编辑<code>limits.conf</code> 添加类似如下内容<br><code>vi /etc/security/limits.conf</code><br>添加如下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br></pre></td></tr></table></figure><hr><h3 id="p3"><a href="#p3" class="headerlink" title="p3"></a>p3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max number of threads [1024] for user [lish] likely too low, increase to at least</span><br></pre></td></tr></table></figure><p>解决：切换到<code>root</code>用户，进入<code>limits.d</code>目录下修改配置文件。<br><code>vi /etc/security/limits.d/90-nproc.conf</code><br>修改如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* soft nproc 1024</span><br><span class="line">#修改为</span><br><span class="line">* soft nproc 2048</span><br></pre></td></tr></table></figure><hr><h3 id="p4"><a href="#p4" class="headerlink" title="p4"></a>p4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]</span><br></pre></td></tr></table></figure><p>解决：切换到root用户修改配置<code>sysctl.conf</code></p><p><code>vi /etc/sysctl.conf</code></p><p>添加下面配置:<code>vm.max_map_count=655360</code></p><p>并执行命令：<code>sysctl -p</code></p><hr><h3 id="p5"><a href="#p5" class="headerlink" title="p5"></a>p5</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536]</span><br></pre></td></tr></table></figure><p>解决：</p><p>修改切换到<code>root</code>用户修改配置<code>limits.conf</code> 添加下面两行<br>命令:<br><code>vi /etc/security/limits.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*        hard    nofile           65536</span><br><span class="line">*        soft    nofile           65536</span><br></pre></td></tr></table></figure><hr><h3 id="p6"><a href="#p6" class="headerlink" title="p6"></a>p6</h3><p>启动Elasticsearch时使用新建的elk用户，启动时报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max number of threads [3895] for user [elk] is too low, increase to at least [4096]</span><br></pre></td></tr></table></figure><p>解决方法：<br><code>root</code>用户修改：<code>vi/etc/security/limits.d/90-nproc.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*          soft    nproc     2048</span><br><span class="line">修改为：</span><br><span class="line">*          soft    nproc     4096</span><br></pre></td></tr></table></figure><hr><h3 id="p7"><a href="#p7" class="headerlink" title="p7"></a>p7</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: [1] bootstrap checks failed</span><br><span class="line">system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk。</span><br></pre></td></tr></table></figure><p>解决：</p><p>Centos6不支持SecComp，而ES5.2.0默认<code>bootstrap.system_call_filter</code>为true</p><p>禁用：</p><p>在elasticsearch.yml中配置 <code>bootstrap.system_call_filter</code>为false，注意要在Memory下面添加:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.memory_lock: false </span><br><span class="line">bootstrap.system_call_filter: false</span><br></pre></td></tr></table></figure><p>再次启动ElasticSearch就能够正常启动了。</p><h3 id="p8"><a href="#p8" class="headerlink" title="p8"></a>p8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the default discovery settings are unsuitable for production use; at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured</span><br></pre></td></tr></table></figure><hr><p><strong>注意</strong>：在外部访问ElasticSearch服务的时候，要停掉CentOS的防火墙，不然仍旧无法访问。<br>防火墙查看命令：<code>service iptables status</code><br>防火墙停止命令：<code>service iptables stop</code></p><p>ElasticSeach后台启动命令：</p><p><code>sh/opt/mysoft/elasticsearch/bin/elasticsearch -d</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;1-安装步骤&quot;&gt;&lt;a href=&quot;#1-安装步骤&quot; class=&quot;headerlink&quot; title=&quot;1.安装步骤&quot;&gt;&lt;/a&gt;1.安
      
    
    </summary>
    
      <category term="elasticsearch" scheme="http://yoursite.com/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="http://yoursite.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch7.0新特性</title>
    <link href="http://yoursite.com/2019/08/30/es/elasticsearch7.0%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/08/30/es/elasticsearch7.0新特性/</id>
    <published>2019-08-29T16:00:00.000Z</published>
    <updated>2019-09-02T08:47:57.654Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><ul><li>Elasticsearch 7.0 默认自带 JDK，不再担心JDK和环境冲突</li><li>默认分片数改为1，不再是5</li><li>==ES数据存储结构变化：去除了Type<br>es6时，官方就提到了es7会删除type，并且es6时已经规定每一个index只能有一个type。在es7中使用默认的_doc作为type，官方说在8.x版本会彻底移除type==<ul><li>==api请求方式也发送变化，如获得某索引的某ID的文档：<code>GET index/_doc/id</code>其中index和id为具体的值==</li><li>链接扩展：<a href="http://note.youdao.com/noteshare?id=96373b8a5580905e69124ed035a241f3&amp;sub=0D5323D7E5DA426AA7E0360482C1AFE7" target="_blank" rel="noopener">http://note.youdao.com/noteshare?id=96373b8a5580905e69124ed035a241f3&amp;sub=0D5323D7E5DA426AA7E0360482C1AFE7</a></li></ul></li><li>集群连接变化：TransportClient被废弃<br>以至于，es7的java代码，只能使用restclient。然后，个人综合了一下，对于java编程，建议采用 High-level-rest-client 的方式操作ES集群</li></ul><h2 id="1-革命性更新"><a href="#1-革命性更新" class="headerlink" title="1.革命性更新"></a>1.革命性更新</h2><h3 id="1-1-查询相关性速度优化"><a href="#1-1-查询相关性速度优化" class="headerlink" title="1.1.查询相关性速度优化"></a>1.1.查询相关性速度优化</h3><p>Weak-AND算法在Term Query查询场景有3700%的性能提升。<br>[<a href="http://www.aboutyun.com/thread-27003-1-1.html]" target="_blank" rel="noopener">http://www.aboutyun.com/thread-27003-1-1.html]</a></p><p>除了Term检索，Fuzzy，Phrase, Bool And .Bool OR都有大幅的性能提升！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">weak-and算法？</span><br><span class="line">核心原理：取TOP N结果集，估算命中记录数。</span><br><span class="line"></span><br><span class="line">简单来说，一般我们在计算文本相关性的时候，会通过倒排索引的方式进行查询，通过倒排索引已经要比全量遍历节约大量时间，但是有时候仍然很慢。</span><br><span class="line">原因是很多时候我们其实只是想要top n个结果，一些结果明显较差的也进行了复杂的相关性计算，</span><br><span class="line">而weak-and算法通过计算每个词的贡献上限来估计文档的相关性上限，从而建立一个阈值对倒排中的结果进行减枝，从而得到提速的效果。</span><br></pre></td></tr></table></figure><p>更快的前 k 个查询：</p><p>在许多搜索用例中，快速查看查询的前 k 个结果对于用户而言比确切的命中数更重要。例如，如果有人在电子商务网站上搜索产品，他们对 10 个最相关的结果更感兴趣，而不是与搜索查询匹配的其他 120 897 个结果。Elasticsearch 7.0 和 Lucene 8.0 实现了一种新算法 Block-Max WAND，可在巨幅提升检索命中前 k 个结果的速度。</p><h3 id="1-2-间隔查询-Intervals-queries"><a href="#1-2-间隔查询-Intervals-queries" class="headerlink" title="1.2.间隔查询(Intervals queries)"></a>1.2.间隔查询(Intervals queries)</h3><p>某些搜索用例（例如，法律和专利搜索）引入了查找单词或短语彼此相距一定距离的记录的需要。</p><p>Elasticsearch 7.0中的间隔查询引入了一种构建此类查询的全新方式，与之前的方法（跨度查询span queries）相比，使用和定义更加简单。</p><p>与跨度查询相比，间隔查询对边缘情况的适应性更强。</p><h3 id="1-3-引入新的集群协调子系统"><a href="#1-3-引入新的集群协调子系统" class="headerlink" title="1.3.引入新的集群协调子系统"></a>1.3.引入新的集群协调子系统</h3><p>移除 <code>minimum_master_nodes</code> 参数，让 Elasticsearch 自己选择可以形成仲裁的节点。</p><p>典型的主节点选举现在只需要很短的时间就可以完成。<br>集群的伸缩变得更安全、更容易，并且可能造成丢失数据的系统配置选项更少了。</p><p>节点更清楚地记录它们的状态，有助于诊断为什么它们不能加入集群或为什么无法选举出主节点。</p><h3 id="1-4-不再内存溢出"><a href="#1-4-不再内存溢出" class="headerlink" title="1.4.不再内存溢出"></a>1.4.不再内存溢出</h3><p>升级到 Elasticsearch 7.0 ,<br>新的 Circuit Breaker 在JVM 堆栈层面监测内存使用，Elasticsearch 比之前更加健壮。</p><p>设置<code>indices.breaker.fielddata.limit</code>的默认值已从JVM堆大小的60％降低到40％。</p><h3 id="1-5-时间戳纳秒级支持，提升数据精度"><a href="#1-5-时间戳纳秒级支持，提升数据精度" class="headerlink" title="1.5.时间戳纳秒级支持，提升数据精度"></a>1.5.时间戳纳秒级支持，提升数据精度</h3><p>利用纳秒精度支持加强时间序列用例</p><p>到目前为止，Elasticsearch仅以毫秒精度存储时间戳。 7.0增加了几个零并带来了纳秒精度，这提高了高频数据采集用户存储和排序所需数据的精度。</p><h3 id="1-6-其他"><a href="#1-6-其他" class="headerlink" title="1.6.其他"></a>1.6.其他</h3><p>Function score 2.0：自定义评分是高级搜索用例的基础，人们希望更好地控制相关性和结果排名，Elasticsearch 从早期就提供了这样的能力。7.0 引入了下一代 function score，提供了一种更简单、模块化与灵活的方式来生成每条记录的排名分数。新的模块化结构允许用户混合和匹配一组算术和距离函数，以构建任意函数分值计算，更好地控制结果的分值和排名。</p><p>此外，Elasticsearch 7.0 中还引入了一个新的聚合来处理地理地图图块，允许用户在地图上放大和缩小，而不会改变结果数据的形状，实现更加平滑地缩放 Elastic Maps；使用纳秒精度存储时序数据的时间戳，允许具有高频数据采集需求的用户可以更加精确地存储和排序他们的数据。</p><p>显然，7.0的特性远不止这些，更多新版本特性推荐阅读：</p><p><a href="http://t.cn/EXyStrW" target="_blank" rel="noopener">http://t.cn/EXyStrW</a></p><p><a href="http://t.cn/EXyStrO" target="_blank" rel="noopener">http://t.cn/EXyStrO</a></p><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/breaking-changes-7.0.html#_literal_network_breaker_inflight_requests_overhead_literal_increased_to_2" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/breaking-changes-7.0.html#_literal_network_breaker_inflight_requests_overhead_literal_increased_to_2</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;
      
    
    </summary>
    
      <category term="elasticsearch" scheme="http://yoursite.com/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="http://yoursite.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>理解springcloud</title>
    <link href="http://yoursite.com/2019/08/30/springcloud/springcloud/"/>
    <id>http://yoursite.com/2019/08/30/springcloud/springcloud/</id>
    <published>2019-08-29T16:00:00.000Z</published>
    <updated>2019-09-02T09:14:45.081Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --><h3 id="深入了解springcloud各个组件的协调工作原理"><a href="#深入了解springcloud各个组件的协调工作原理" class="headerlink" title="深入了解springcloud各个组件的协调工作原理"></a>深入了解springcloud各个组件的协调工作原理</h3><h4 id="相关业务-订单服务的理解（支付订单）"><a href="#相关业务-订单服务的理解（支付订单）" class="headerlink" title="相关业务-订单服务的理解（支付订单）"></a>相关业务-订单服务的理解（支付订单）</h4><ul><li>创建一个订单，用户支付，订单状态改变</li><li>库存扣减相应的库存</li><li>通知仓储中心发货</li><li>给用户这个的购物增加积分</li></ul><p><strong>争对上述订单流程，可以得到有几个模块：订单模块、库存模块、存储服务、积分服务</strong></p><h2 id="1、-Eureka-juˈriːkə"><a href="#1、-Eureka-juˈriːkə" class="headerlink" title="1、 Eureka[juˈriːkə]"></a>1、 Eureka[juˈriːkə]</h2><p><strong>订单服务想要调用库存服务、仓储服务，或者是积分服务，怎么调用？</strong></p><ul><li><p>订单服务压根儿就不知道人家库存服务在哪台机器上啊！他就算想要发起一个请求，都不知道发送给谁，有心无力！</p></li><li><p>这时候，就轮到Spring Cloud Eureka出场了。Eureka是微服务架构中的注册中心，专门负责服务的注册与发现。</p></li></ul><p><code>库存服务、仓储服务、积分服务中都有一个Eureka Client组件，这个组件专门负责将这个服务的信息注册到Eureka Server中。说白了，就是告诉Eureka Server，自己在哪台机器上，监听着哪个端口。而Eureka Server是一个注册中心，里面有一个注册表，保存了各服务所在的机器和端口号</code></p><p><code>订单服务里也有一个Eureka Client组件，这个Eureka Client组件会找Eureka Server问一下：库存服务在哪台机器啊？监听着哪个端口啊？仓储服务呢？积分服务呢？然后就可以把这些相关信息从Eureka Server的注册表中拉取到自己本地缓存起来。</code></p><p><code>这时如果订单服务想要调用库存服务，不就可以找自己本地的Eureka Client问一下库存服务在哪台机器？监听哪个端口吗？收到响应后，紧接着就可以发送一个请求过去，调用库存服务扣减库存的那个接口！同理，如果订单服务要调用仓储服务、积分服务，也是如法炮制。</code></p><ul><li><input checked disabled type="checkbox"> sum</li><li>Eureka Client：负责将这个服务的信息注册到Eureka Server中</li><li>Eureka Server：注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号</li></ul><h2 id="2、-Feign-feɪn"><a href="#2、-Feign-feɪn" class="headerlink" title="2、 Feign[feɪn]"></a>2、 Feign[feɪn]</h2><p>Feign Client会在底层根据你的注解，跟你指定的服务建立连接、构造请求、发起靕求、获取响应、解析响应，等等。服务间调用时，不必每次都手写代码</p><ul><li>首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理</li></ul><ul><li><p>接着你要是调用那个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心</p></li><li><p>Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址</p></li><li><p>最后针对这个地址，发起请求、解析响应</p></li></ul><h2 id="3、-Ribbon-riben"><a href="#3、-Ribbon-riben" class="headerlink" title="3、 Ribbon[`riben]"></a>3、 Ribbon[`riben]</h2><p>说完了Feign，还没完。现在新的问题又来了，如果人家库存服务部署在了5台机器上，如下所示：</p><ul><li><p>192.168.169:9000</p></li><li><p>192.168.170:9000</p></li><li><p>192.168.171:9000</p></li><li><p>192.168.172:9000</p></li><li><p>192.168.173:9000</p></li></ul><p><code>Feign怎么知道该请求哪台机器呢？</code></p><p>Ribbon就是专门解决这个问题的。它的作用是负载均衡，会帮你在每次请求时选择一台机器，均匀的把请求分发到各个机器上</p><p><code>Ribbon的负载均衡默认使用的最经典的Round Robin轮询算法。这是啥？简单来说，就是如果订单服务对库存服务发起10次请求，那就先让你请求第1台机器、然后是第2台机器、第3台机器、第4台机器、第5台机器，接着再来—个循环，第1台机器、第2台机器。。。以此类推。</code></p><p>此外，Ribbon是和Feign以及Eureka紧密协作，完成工作的，具体如下：</p><ul><li><p>首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。</p></li><li><p>然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器</p></li><li><p>Feign就会针对这台机器，构造并发起请求。</p></li></ul><h2 id="4、Hystrix"><a href="#4、Hystrix" class="headerlink" title="4、Hystrix"></a>4、Hystrix</h2><p>在微服务架构里，一个系统会有很多的服务。以本文的业务场景为例：订单服务在一个业务流程里需要调用三个服务。现在假设订单服务自己最多只有100个线程可以处理请求，然后呢，积分服务不幸的挂了，每次订单服务调用积分服务的时候，都会卡住几秒钟，然后抛出—个超时异常。</p><p><strong>咱们一起来分析一下，这样会导致什么问题？</strong></p><ul><li>如果系统处于高并发的场景下，大量请求涌过来的时候，订单服务的100个线程都会卡在请求积分服务这块。导致订单服务没有一个线程可以处理请求</li></ul><ul><li>然后就会导致别人请求订单服务的时候，发现订单服务也挂了，不响应任何请求了</li></ul><p>上面这个，就是微服务架构中恐怖的服务雪崩问题</p><p>如上图，这么多服务互相调用，要是不做任何保护的话，某一个服务挂了，就会引起连锁反应，导致别的服务也挂。比如积分服务挂了，会导致订单服务的线程全部卡在请求积分服务这里，没有一个线程可以工作，瞬间导致订单服务也挂了，别人请求订单服务全部会卡住，无法响应。</p><p><code>这时就轮到Hystrix闪亮登场了。Hystrix是隔离、熔断以及降级的一个框架。啥意思呢？说白了，Hystrix会搞很多个小小的线程池，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务。</code></p><p><code>这个时候如果别人请求订单服务，订单服务还是可以正常调用库存服务扣减库存，调用仓储服务通知发货。只不过调用积分服务的时候，每次都会报错。但是如果积分服务都挂了，每次调用都要去卡住几秒钟干啥呢？有意义吗？当然没有！所以我们直接对积分服务熔断不就得了，比如在5分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟，这个过程，就是所谓的熔断！</code></p><p><code>那人家又说，兄弟，积分服务挂了你就熔断，好歹你干点儿什么啊！别啥都不干就直接返回啊？没问题，咱们就来个降级：每次调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。这个过程，就是所谓的降级。</code></p><h2 id="5、Zuul"><a href="#5、Zuul" class="headerlink" title="5、Zuul"></a>5、Zuul</h2><p>说完了Hystrix，接着给大家说说最后一个组件：Zuul，也就是微服务网关。这个组件是负责网络路由的。不懂网络路由？行，那我给你说说，如果没有Zuul的日常工作会怎样？</p><ul><li>假设你后台部署了几百个服务，现在有个前端兄弟，人家请求是直接从浏览器那儿发过来的。打个比方：人家要请求一下库存服务，你难道还让人家记着这服务的名字叫做inventory-service？部署在5台机器上？就算人家肯记住这一个，你后台可有几百个服务的名称和地址呢？难不成人家请求一个，就得记住一个？你要这样玩儿，那真是友谊的小船，说翻就翻！</li></ul><ul><li>上面这种情况，压根儿是不现实的。所以一般微服务架构中都必然会设计一个网关在里面，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。</li></ul><h2 id="6、总结："><a href="#6、总结：" class="headerlink" title="6、总结："></a>6、总结：</h2><p>最后再来总结一下，上述几个Spring Cloud核心组件，在微服务架构中，分别扮演的角色：</p><ul><li><p>Eureka：各个服务启动时，EurekaClient都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里</p></li><li><p>Ribbon：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台</p></li><li><p>Feign：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求</p></li><li><p>Hystrix：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题</p></li><li><p>Zuul：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务</p></li></ul><p><code>以上就是我们通过一个电商业务场景，阐述了Spring Cloud微服务架构几个核心组件的底层原理。 而且有一个网关之后，还有很多好处，比如可以做统一的降级、限流、认证授权、安全，等等。</code></p><p><code>博文地址：https://blog.csdn.net/forezp/article/details/83999882</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;深入了解springcloud各个组件的协调工作原理&quot;&gt;&lt;a href=&quot;#深入了解springcloud各个组件的协调工作原理&quot; c
      
    
    </summary>
    
      <category term="springcloud" scheme="http://yoursite.com/categories/springcloud/"/>
    
    
      <category term="springcloud" scheme="http://yoursite.com/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Data Elasticsearch</title>
    <link href="http://yoursite.com/2019/08/30/es/Spring%20Data%20Elasticsearch%EF%BC%88es5.6.3%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/30/es/Spring Data Elasticsearch（es5.6.3）/</id>
    <published>2019-08-29T16:00:00.000Z</published>
    <updated>2019-09-02T08:44:30.889Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --><h1 id="Spring-Data-Elasticsearch"><a href="#Spring-Data-Elasticsearch" class="headerlink" title="Spring Data Elasticsearch"></a>Spring Data Elasticsearch</h1><p>Elasticsearch提供的Java客户端有一些不太方便的地方：</p><ul><li>很多地方需要拼接Json字符串，在java中拼接字符串有多恐怖你应该懂的</li><li>需要自己把对象序列化为json存储</li><li>查询到结果也需要自己反序列化为对象</li></ul><p>因此，这里学习下Spring提供的套件Spring Data Elasticsearch，暂不了解原生的Elasticsearch客户端API</p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>Spring Data Elasticsearch是Spring Data项目下的一个子模块。</p><p>查看 Spring Data的官网：<a href="http://projects.spring.io/spring-data/" target="_blank" rel="noopener">http://projects.spring.io/spring-data/</a></p><blockquote><p>Spring Data的使命是为数据访问提供熟悉且一致的基于Spring的编程模型，同时仍保留底层数据存储的特殊特性。</p><p>它使得使用数据访问技术，关系数据库和非关系数据库，map-reduce框架和基于云的数据服务变得容易。这是一个总括项目，其中包含许多特定于给定数据库的子项目。这些令人兴奋的技术项目背后，是由许多公司和开发人员合作开发的。</p></blockquote><p>Spring Data 的使命是给各种数据访问提供统一的编程接口，不管是关系型数据库（如MySQL），还是非关系数据库（如Redis），或者类似Elasticsearch这样的索引数据库。从而简化开发人员的代码，提高开发效率。</p><p>包含很多不同数据操作的模块：</p><p><img src="https://i.loli.net/2019/08/05/aKzl2QEe7NU9Ih1.png" alt="1531753715580.png"></p><p>Spring Data Elasticsearch的页面：<a href="https://projects.spring.io/spring-data-elasticsearch/" target="_blank" rel="noopener">https://projects.spring.io/spring-data-elasticsearch/</a></p><p>特征：</p><ul><li>支持Spring的基于<code>@Configuration</code>的java配置方式，或者XML配置方式</li><li>提供了用于操作ES的便捷工具类<strong><code>ElasticsearchTemplate</code></strong>。包括实现文档到POJO之间的自动智能映射。</li><li>利用Spring的数据转换服务实现的功能丰富的对象映射</li><li>基于注解的元数据映射方式，而且可扩展以支持更多不同的数据格式</li><li>根据持久层接口自动生成对应实现方法，无需人工编写基本操作代码（类似mybatis，根据接口自动得到实现）。当然，也支持人工定制查询</li></ul><h2 id="2-对比原生API"><a href="#2-对比原生API" class="headerlink" title="2.对比原生API"></a>2.对比原生API</h2><p>Elasticsearch 原生 API 好处就是可以第一时间用到 Elasticsearch 的新特性。缺点的学习成本高。</p><p>用 Spring Data 的好处是，用统一的接口，适配所有不同的存储类型，如SQL、NoSQL 等等。缺点是，有时候适配的版本要比原生的 API 要慢。这个取决于 Spring Data Elasticsearch 团队的开发速度了</p><table><thead><tr><th>Spring Data Elasticsearch</th><th>Elasticsearch</th></tr></thead><tbody><tr><td>3.2.x</td><td>6.7.2</td></tr><tr><td>3.1.x</td><td>6.2.2</td></tr><tr><td>3.0.x</td><td>5.5.0</td></tr><tr><td>2.1.x</td><td>2.4.0</td></tr><tr><td>2.0.x</td><td>2.2.0</td></tr><tr><td>1.3.x</td><td>1.5.2</td></tr></tbody></table><h2 id="3-创建Demo工程"><a href="#3-创建Demo工程" class="headerlink" title="3..创建Demo工程"></a>3..创建Demo工程</h2><p>新建一个demo，学习Elasticsearch</p><p>pom依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml文件配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    elasticsearch:</span></span><br><span class="line"><span class="attr">      cluster-name:</span> <span class="string">elasticsearch</span></span><br><span class="line">      <span class="comment">#9300：集群节点间通讯接口  9200：客户端访问接口</span></span><br><span class="line"><span class="attr">      cluster-nodes:</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.101</span><span class="string">:9300</span></span><br></pre></td></tr></table></figure><h2 id="4-实体类及注解"><a href="#4-实体类及注解" class="headerlink" title="4..实体类及注解"></a>4..实体类及注解</h2><p>首先准备好实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"items"</span>, type = <span class="string">"books"</span>, shards = <span class="number">1</span>, replicas = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.text, analyzer = <span class="string">"ik_max_word"</span>)</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.keyword)</span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Double)</span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(index = <span class="keyword">false</span>, type = FieldType.keyword)</span><br><span class="line">    <span class="keyword">private</span> String images;</span><br></pre></td></tr></table></figure><blockquote><p>映射</p></blockquote><p>Spring Data通过注解来声明字段的映射属性，有下面的三个注解：</p><ul><li><p><code>@Document</code> 作用在类，标记实体类为文档对象，一般有两个属性</p><ul><li>indexName：对应索引库名称</li><li>type：对应在索引库中的类型</li><li>shards：分片数量，默认5</li><li>replicas：副本数量，默认1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String indexName();//索引库的名称，建议以项目的名称命名</span><br><span class="line"> </span><br><span class="line">String type() default &quot;&quot;;//类型，建议以实体的名称命名</span><br><span class="line"> </span><br><span class="line">short shards() default 5;//默认分区数</span><br><span class="line"> </span><br><span class="line">short replicas() default 1;//每个分区默认的备份数</span><br><span class="line"> </span><br><span class="line">String refreshInterval() default &quot;1s&quot;;//刷新间隔</span><br><span class="line"> </span><br><span class="line">String indexStoreType() default &quot;fs&quot;;//索引文件存储类型</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>@Id</code> 作用在成员变量，在Elasticsearch里相应于该列就是主键了，在查询时就可以直接用主键查询</p></li><li><p><code>@Field</code> 作用在成员变量，标记为文档的字段，并指定字段映射属性：</p><ul><li>type：字段类型，取值是枚举：FieldType</li><li>index：是否索引，布尔类型，默认是true</li><li>store：是否存储，布尔类型，默认是false</li><li>analyzer：分词器名称</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public @interface Field &#123;</span><br><span class="line"> </span><br><span class="line">FieldType type() default FieldType.Auto;#自动检测属性的类型</span><br><span class="line"> </span><br><span class="line">FieldIndex index() default FieldIndex.analyzed;#默认情况下分词</span><br><span class="line"> </span><br><span class="line">DateFormat format() default DateFormat.none;</span><br><span class="line"> </span><br><span class="line">String pattern() default &quot;&quot;;</span><br><span class="line"> </span><br><span class="line">boolean store() default false;#默认情况下不存储原文</span><br><span class="line"> </span><br><span class="line">String searchAnalyzer() default &quot;&quot;;#指定字段搜索时使用的分词器</span><br><span class="line"> </span><br><span class="line">String indexAnalyzer() default &quot;&quot;;#指定字段建立索引时指定的分词器</span><br><span class="line"> </span><br><span class="line">String[] ignoreFields() default &#123;&#125;;#如果某个字段需要被忽略</span><br><span class="line"> </span><br><span class="line">boolean includeInParent() default false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Template索引操作"><a href="#5-Template索引操作" class="headerlink" title="5.Template索引操作"></a>5.Template索引操作</h2><h3 id="5-1-创建索引和映射"><a href="#5-1-创建索引和映射" class="headerlink" title="5.1.创建索引和映射"></a>5.1.创建索引和映射</h3><blockquote><p>创建索引</p></blockquote><p>ElasticsearchTemplate中提供了创建索引的API：</p><hr><p><img src="https://i.loli.net/2019/08/06/5P6mt87zDxpYVSw.png" alt="11.png"></p><p>可以根据类的信息自动生成，也可以手动指定indexName和Settings</p><blockquote><p>映射</p></blockquote><p>映射相关的API：</p><p><img src="https://i.loli.net/2019/08/06/CnDV48aUGW2qeA3.png" alt="12.png"></p><p>可以根据类的字节码信息（注解配置）来生成映射，或者手动编写映射</p><p>这里采用类的字节码信息创建索引并映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = ItcastElasticsearchApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ElasticsearchTemplate elasticsearchTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建索引，会根据Item类的@Document注解信息来创建</span></span><br><span class="line">        elasticsearchTemplate.createIndex(Item.class);</span><br><span class="line">        <span class="comment">// 配置映射，会根据Item类中的id、Field等字段来自动完成映射</span></span><br><span class="line">        elasticsearchTemplate.putMapping(Item.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-删除索引"><a href="#5-2-删除索引" class="headerlink" title="5.2.删除索引"></a>5.2.删除索引</h3><p>根据类名或索引名删除索引的API。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    esTemplate.deleteIndex(<span class="string">"items"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><code>HEAD wind ---404</code></p><h2 id="6-Repository文档操作"><a href="#6-Repository文档操作" class="headerlink" title="6.Repository文档操作"></a>6.Repository文档操作</h2><p>Spring Data 的强大之处，就在于你不用写任何DAO处理，自动根据方法名或类的信息进行CRUD操作。只要你定义一个接口，然后继承Repository提供的一些子接口，就能具备各种基本的CRUD功能。</p><p>我们只需要定义接口，然后继承它就OK了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemMapper</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Item</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-新增文档"><a href="#6-1-新增文档" class="headerlink" title="6.1.新增文档"></a>6.1.新增文档</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> ItemMapper itemMapper;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Item item = <span class="keyword">new</span> Item(<span class="number">1L</span>, <span class="string">"三体"</span>, <span class="string">"科幻"</span>, <span class="number">199.00</span>, <span class="string">"http://image.xxx.com/123.jpg"</span>);</span><br><span class="line">       itemMapper.save(item);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>去页面查询看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /items/books/1</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"items"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"books"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"时间简史"</span>,</span><br><span class="line">    <span class="attr">"category"</span>: <span class="string">"科幻"</span>,</span><br><span class="line">    <span class="attr">"price"</span>: <span class="number">99</span>,</span><br><span class="line">    <span class="attr">"images"</span>: <span class="string">"http://image.xxx.com/123.jpg"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-批量新增"><a href="#6-2-批量新增" class="headerlink" title="6.2.批量新增"></a>6.2.批量新增</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itemMapper.saveAll(list);</span><br></pre></td></tr></table></figure><h3 id="6-3-修改文档"><a href="#6-3-修改文档" class="headerlink" title="6.3.修改文档"></a>6.3.修改文档</h3><p>修改和新增是同一个接口，区分的依据就是id，这一点跟我们在页面发起PUT请求是类似的。</p><h3 id="6-4-基本查询"><a href="#6-4-基本查询" class="headerlink" title="6.4.基本查询"></a>6.4.基本查询</h3><p>ElasticsearchRepository提供了一些基本的查询方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 查询全部，并安装价格降序排序</span></span><br><span class="line">       Iterable&lt;Item&gt; items = <span class="keyword">this</span>.itemMapper.findAll(Sort.by(Sort.Direction.DESC, <span class="string">"price"</span>));</span><br><span class="line">       <span class="comment">//items.forEach(t -&gt; System.out.println(t));</span></span><br><span class="line">       items.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Item(id=6, title=三体3, category=科幻, price=299.0, images=http://image.xxx.com/3453123.jpg)</span><br><span class="line">Item(id=1, title=时间简史, category=科幻, price=99.0, images=http://image.xxx.com/3453123.jpg)</span><br><span class="line">Item(id=4, title=悲惨世界, category=文学, price=89.0, images=http://image.xxx.com/3453123.jpg)</span><br><span class="line">Item(id=5, title=世界上下五千年, category=文学, price=79.0, images=http://image.xxx.com/3453123.jpg)</span><br><span class="line">Item(id=2, title=时间都去哪了, category=生活, price=69.0,  images=http://image.xxx.com/3453123.jpg)</span><br><span class="line">Item(id=3, title=时间管理, category=生活, price=49.0, images=http://image.xxx.com/3453123.jpg)</span><br></pre></td></tr></table></figure><h3 id="6-5-自定义方法"><a href="#6-5-自定义方法" class="headerlink" title="6.5.自定义方法"></a>6.5.自定义方法</h3><p>Spring Data 的另一个强大功能，是根据方法名称自动实现功能。</p><p>比如：你的方法名叫做：findByTitle，那么它就知道你是根据title查询，然后自动帮你完成，无需写实现类。</p><p>当然，方法名称要符合一定的约定：</p><table><thead><tr><th>Keyword</th><th>Sample</th><th>Elasticsearch Query String</th></tr></thead><tbody><tr><td><code>And</code></td><td><code>findByNameAndPrice</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;price&quot; : &quot;?&quot;}} ]}}</code></td></tr><tr><td><code>Or</code></td><td><code>findByNameOrPrice</code></td><td><code>{&quot;bool&quot; : {&quot;should&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;price&quot; : &quot;?&quot;}} ]}}</code></td></tr><tr><td><code>Is</code></td><td><code>findByName</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}}</code></td></tr><tr><td><code>Not</code></td><td><code>findByNameNot</code></td><td><code>{&quot;bool&quot; : {&quot;must_not&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}}</code></td></tr><tr><td><code>Between</code></td><td><code>findByPriceBetween</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>LessThanEqual</code></td><td><code>findByPriceLessThan</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>GreaterThanEqual</code></td><td><code>findByPriceGreaterThan</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>Before</code></td><td><code>findByPriceBefore</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>After</code></td><td><code>findByPriceAfter</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}}</code></td></tr><tr><td><code>Like</code></td><td><code>findByNameLike</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true}}}}}</code></td></tr><tr><td><code>StartingWith</code></td><td><code>findByNameStartingWith</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true}}}}}</code></td></tr><tr><td><code>EndingWith</code></td><td><code>findByNameEndingWith</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;*?&quot;,&quot;analyze_wildcard&quot; : true}}}}}</code></td></tr><tr><td><code>Contains/Containing</code></td><td><code>findByNameContaining</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;**?**&quot;,&quot;analyze_wildcard&quot; : true}}}}}</code></td></tr><tr><td><code>In</code></td><td><code>findByNameIn(Collection&lt;String&gt;names)</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;bool&quot; : {&quot;should&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}} ]}}}}</code></td></tr><tr><td><code>NotIn</code></td><td><code>findByNameNotIn(Collection&lt;String&gt;names)</code></td><td><code>{&quot;bool&quot; : {&quot;must_not&quot; : {&quot;bool&quot; : {&quot;should&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}}}}</code></td></tr><tr><td><code>Near</code></td><td><code>findByStoreNear</code></td><td><code>Not Supported Yet !</code></td></tr><tr><td><code>True</code></td><td><code>findByAvailableTrue</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : true}}}}</code></td></tr><tr><td><code>False</code></td><td><code>findByAvailableFalse</code></td><td><code>{&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : false}}}}</code></td></tr><tr><td><code>OrderBy</code></td><td><code>findByAvailableTrueOrderByNameDesc</code></td><td><code>{&quot;sort&quot; : [{ &quot;name&quot; : {&quot;order&quot; : &quot;desc&quot;} }],&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : true}}}}</code></td></tr></tbody></table><p>例如，来按照价格区间查询，定义这样的一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据价格区间查询</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> price1</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> price2</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function">List&lt;Item&gt; <span class="title">findByPriceBetween</span><span class="params">(<span class="keyword">double</span> price1, <span class="keyword">double</span> price2)</span></span>;</span><br></pre></td></tr></table></figure><p>不需要写实现类，直接运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void queryByPriceBetween() &#123;</span><br><span class="line">       List&lt;Item&gt; list = this.itemMapper.findByPriceBetween(50.00, 100.00);</span><br><span class="line">       list.forEach(t -&gt; System.out.println(t));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>虽然基本查询和自定义方法已经很强大了，但是如果是复杂查询（模糊、通配符、词条查询等）,此时只能使用原生查询。</p><h2 id="7-高级查询"><a href="#7-高级查询" class="headerlink" title="7.高级查询"></a>7.高级查询</h2><h3 id="7-1-基本查询"><a href="#7-1-基本查询" class="headerlink" title="7.1.基本查询"></a>7.1.基本查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 词条查询</span></span><br><span class="line">    MatchQueryBuilder queryBuilder = QueryBuilders.matchQuery(<span class="string">"title"</span>, <span class="string">"时间"</span>);</span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    Iterable&lt;Item&gt; items = <span class="keyword">this</span>.itemMapper.search(queryBuilder);</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ItemMapper的search方法需要QueryBuilder参数，elasticSearch为我们提供了一个对象QueryBuilders；</p><p>QueryBuilders提供了大量的静态方法，用于生成各种不同类型的查询对象，例如：词条、模糊、通配符等QueryBuilder对象。</p><p>es提供很多可用的查询方式，但是不够灵活。如果用过滤或者聚合查询等就很难了。</p><h3 id="7-2-自定义查询"><a href="#7-2-自定义查询" class="headerlink" title="7.2.自定义查询"></a>7.2.自定义查询</h3><p>最基本的match query：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativeQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构建查询条件</span></span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.matchQuery(<span class="string">"title"</span>, <span class="string">"时间"</span>));</span><br><span class="line">    <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">    Page&lt;Item&gt; items = <span class="keyword">this</span>.itemRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 打印总条数</span></span><br><span class="line">    System.out.println(items.getTotalElements());</span><br><span class="line">    <span class="comment">// 打印总页数</span></span><br><span class="line">    System.out.println(items.getTotalPages());</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">总条数：3</span><br><span class="line">总页数：1</span><br><span class="line">Item(id=1, title=时间简史, category=科幻, price=99.0, images=http://image.xxx.com/3453123.jpg)</span><br><span class="line">Item(id=2, title=时间都去哪了, category=生活, price=69.0, images=http://image.xxx.com/3453123.jpg)</span><br><span class="line">Item(id=3, title=时间管理, category=生活, price=49.0, images=http://image.xxx.com/3453123.jpg)</span><br></pre></td></tr></table></figure><p>NativeSearchQueryBuilder：Spring提供的一个查询条件构建器，帮助构建json格式的请求体</p><p><code>Page&lt;item&gt;</code>：默认是分页查询，因此返回的是一个分页的结果对象，包含属性：</p><ul><li>totalElements：总条数</li><li>totalPages：总页数</li><li>Iterator：迭代器，本身实现了Iterator接口，因此可直接迭代得到当前页的数据</li><li>其它属性</li></ul><h3 id="7-3-分页查询"><a href="#7-3-分页查询" class="headerlink" title="7.3.分页查询"></a>7.3.分页查询</h3><p>利用<code>NativeSearchQueryBuilder</code>可以方便的实现分页：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativeQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构建查询条件</span></span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">    <span class="comment">// 添加基本的分词查询</span></span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.termQuery(<span class="string">"category"</span>, <span class="string">"文学"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化分页参数</span></span><br><span class="line">    <span class="keyword">int</span> page = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 设置分页参数</span></span><br><span class="line">    queryBuilder.withPageable(PageRequest.of(page, size));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行搜索，获取结果</span></span><br><span class="line">    Page&lt;Item&gt; items = <span class="keyword">this</span>.itemRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">// 打印总条数</span></span><br><span class="line">    System.out.println(items.getTotalElements());</span><br><span class="line">    <span class="comment">// 打印总页数</span></span><br><span class="line">    System.out.println(items.getTotalPages());</span><br><span class="line">    <span class="comment">// 每页大小</span></span><br><span class="line">    <span class="comment">//2.0.1.RELEASE这里的getSize无返回结果,2.0.4.RELEASE可以</span></span><br><span class="line">    System.out.println(items.getSize());</span><br><span class="line">    <span class="comment">// 当前页</span></span><br><span class="line">    <span class="comment">//2.0.1.RELEASE这里的getNumber无返回结果</span></span><br><span class="line">    System.out.println(items.getNumber());</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">总条数：4</span><br><span class="line">总页数：2</span><br><span class="line">每页大小：2</span><br><span class="line">当前页：1</span><br><span class="line">Item(id=6, title=三体, category=文学, price=199.0, images=http://image.xxx.com/3453123.jpg)</span><br><span class="line">Item(id=7, title=三体2, category=文学, price=199.0, images=http://image.xxx.com/12324.jpg)</span><br></pre></td></tr></table></figure><p>可以发现，<strong>Elasticsearch中的分页是从第0页开始</strong>。</p><h3 id="7-4-排序"><a href="#7-4-排序" class="headerlink" title="7.4.排序"></a>7.4.排序</h3><p>排序也通用通过<code>NativeSearchQueryBuilder</code>完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSort()&#123;</span><br><span class="line">    // 构建查询条件</span><br><span class="line">    NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder();</span><br><span class="line">    // 添加基本的分词查询</span><br><span class="line">    queryBuilder.withQuery(QueryBuilders.termQuery(&quot;category&quot;, &quot;文学&quot;));</span><br><span class="line">    // 排序</span><br><span class="line">    queryBuilder.withSort(SortBuilders.fieldSort(&quot;price&quot;).order(SortOrder.DESC));</span><br><span class="line">    // 执行搜索，获取结果</span><br><span class="line">    Page&lt;Item&gt; items = this.itemRepository.search(queryBuilder.build());</span><br><span class="line">    // 打印总条数</span><br><span class="line">    System.out.println(items.getTotalElements());</span><br><span class="line">    // 遍历</span><br><span class="line">    items.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">Item(id=6, title=三体, category=文学, price=199.0, images=http://image.xxx.com/3453123.jpg)</span><br><span class="line">Item(id=7, title=三体2, category=文学, price=199.0, images=http://image.xxx.com/12324.jpg)</span><br><span class="line">Item(id=4, title=悲惨世界, category=文学, price=89.0, images=http://image.xxx.com/3453123.jpg)</span><br><span class="line">Item(id=5, title=世界上下五千年, category=文学, price=79.0, images=http://image.xxx.com/3453123.jpg)</span><br></pre></td></tr></table></figure><h2 id="8-聚合"><a href="#8-聚合" class="headerlink" title="8.聚合"></a>8.聚合</h2><h3 id="8-1-聚合为桶"><a href="#8-1-聚合为桶" class="headerlink" title="8.1.聚合为桶"></a>8.1.聚合为桶</h3><p>桶就是分组，比如按照类型<code>category</code>进行分组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAgg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">        <span class="comment">// 不查询任何结果</span></span><br><span class="line">        queryBuilder.withSourceFilter(<span class="keyword">new</span> FetchSourceFilter(<span class="keyword">new</span> String[]&#123;<span class="string">""</span>&#125;, <span class="keyword">null</span>));</span><br><span class="line">        <span class="comment">// 1、添加一个新的聚合，聚合类型为terms，聚合名称为categories，聚合字段为category</span></span><br><span class="line">        queryBuilder.addAggregation(</span><br><span class="line">                AggregationBuilders.terms(<span class="string">"categories"</span>).field(<span class="string">"category"</span>));</span><br><span class="line">        <span class="comment">// 2、查询,需要把结果强转为AggregatedPage类型</span></span><br><span class="line">        AggregatedPage&lt;Item&gt; aggPage = (AggregatedPage&lt;Item&gt;) <span class="keyword">this</span>.itemMapper.search(queryBuilder.build());</span><br><span class="line">        <span class="comment">//3.1、解析从结果中取出名为brands的那个聚合，因为是利用String类型字段来进行的term聚合，所以结果要强转为StringTerm类型</span></span><br><span class="line">        StringTerms agg = (StringTerms) aggPage.getAggregation(<span class="string">"categories"</span>);</span><br><span class="line">        <span class="comment">// 3.2、获取桶</span></span><br><span class="line">        List&lt;StringTerms.Bucket&gt; buckets = agg.getBuckets();</span><br><span class="line">        <span class="comment">// 3.3、遍历</span></span><br><span class="line">        <span class="keyword">for</span> (StringTerms.Bucket bucket : buckets) &#123;</span><br><span class="line">            <span class="comment">// 3.4、获取桶中的key，即类型名称</span></span><br><span class="line">            System.out.println(bucket.getKeyAsString());</span><br><span class="line">            <span class="comment">// 3.5、获取桶中的文档数量</span></span><br><span class="line">            System.out.println(bucket.getDocCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文学</span><br><span class="line">4</span><br><span class="line">生活</span><br><span class="line">2</span><br><span class="line">科幻</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>关键API：</p><ul><li><p><code>AggregationBuilders</code>：聚合的构建工厂类。所有聚合都由这个类来构建</p></li><li><p><code>AggregatedPage</code>：聚合查询的结果类。它是<code>Page&lt;T&gt;</code>的子接口;</p><p><code>AggregatedPage</code>在<code>Page</code>功能的基础上，拓展了与聚合相关的功能，它其实就是对聚合结果的一种封装，可以对照聚合结果的JSON结构来看。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface AggregatedPage&lt;T&gt; extends FacetedPage&lt;T&gt;, ScrolledPage&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    boolean hasAggregations();  //判断结果中是否有聚合</span><br><span class="line"></span><br><span class="line">    Aggregations getAggregations();  //获取所有聚合形成的map，key是聚合名称</span><br><span class="line"></span><br><span class="line">    Aggregation getAggregation(String var1);  //根据聚合名称，获取指定集合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而返回的结果都是Aggregation<code>[ˌæɡrɪˈɡeɪʃn]</code>类型对象，不过根据字段类型不同，又有不同的子类表示</p><p>查询的JSON结果与Java类的对照关系（等长虚线为区间）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  &quot;aggregations&quot;: &#123;     //aggregations聚合结果对象，可以包含多个聚合，对应API中的AggregatedPage</span><br><span class="line">    &quot;categories&quot;: &#123;     //categories 聚合的名称，区分多个聚合的key</span><br><span class="line">------&quot;doc_count_error_upper_bound&quot;: 0,-----------------------------------------------------</span><br><span class="line">      &quot;sum_other_doc_count&quot;: 0,</span><br><span class="line">      &quot;buckets&quot;: [     //buckets 桶的数组，java中的Bucket集合</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: &quot;文学&quot;,</span><br><span class="line">          &quot;doc_count&quot;: 4</span><br><span class="line">        &#125;,</span><br><span class="line">       -&#123;------------------------------------------------------------------------</span><br><span class="line">          &quot;key&quot;: &quot;生活&quot;,                </span><br><span class="line">          &quot;doc_count&quot;: 2   </span><br><span class="line">       -&#125;,-------------------一个桶，有key和文档数量，或其他结果取决于聚合类型-------</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: &quot;科幻&quot;,</span><br><span class="line">          &quot;doc_count&quot;: 1</span><br><span class="line">        &#125;  </span><br><span class="line"> -----]------------------对应的值是一个对象，在JavaAPI中就是Aggregation对象，也可以是它的子类，StringTerms，LongTerms，DoubleTerms等-----------------------------------------------</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-嵌套聚合，求平均值"><a href="#8-2-嵌套聚合，求平均值" class="headerlink" title="8.2.嵌套聚合，求平均值"></a>8.2.嵌套聚合，求平均值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSubAgg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       NativeSearchQueryBuilder queryBuilder = <span class="keyword">new</span> NativeSearchQueryBuilder();</span><br><span class="line">       <span class="comment">// 不查询任何结果</span></span><br><span class="line">       queryBuilder.withSourceFilter(<span class="keyword">new</span> FetchSourceFilter(<span class="keyword">new</span> String[]&#123;<span class="string">""</span>&#125;, <span class="keyword">null</span>));</span><br><span class="line">       <span class="comment">// 1、添加一个新的聚合，聚合类型为terms，聚合名称为brands，聚合字段为brand</span></span><br><span class="line">       queryBuilder.addAggregation(</span><br><span class="line">               AggregationBuilders.terms(<span class="string">"categories"</span>).field(<span class="string">"category"</span>)</span><br><span class="line">                       .subAggregation(AggregationBuilders.avg(<span class="string">"priceAvg"</span>).field(<span class="string">"price"</span>)) <span class="comment">// 在品牌聚合桶内进行嵌套聚合，求平均值</span></span><br><span class="line">       );</span><br><span class="line">       <span class="comment">// 2、查询,需要把结果强转为AggregatedPage类型</span></span><br><span class="line">       AggregatedPage&lt;Item&gt; aggPage = (AggregatedPage&lt;Item&gt;) <span class="keyword">this</span>.itemMapper.search(queryBuilder.build());</span><br><span class="line">       <span class="comment">// 3、解析</span></span><br><span class="line">       <span class="comment">// 3.1、从结果中取出名为brands的那个聚合，</span></span><br><span class="line">       <span class="comment">// 因为是利用String类型字段来进行的term聚合，所以结果要强转为StringTerm类型</span></span><br><span class="line">       StringTerms agg = (StringTerms) aggPage.getAggregation(<span class="string">"categories"</span>);</span><br><span class="line">       <span class="comment">// 3.2、获取桶</span></span><br><span class="line">       List&lt;StringTerms.Bucket&gt; buckets = agg.getBuckets();</span><br><span class="line">       <span class="comment">// 3.3、遍历</span></span><br><span class="line">       <span class="keyword">for</span> (StringTerms.Bucket bucket : buckets) &#123;</span><br><span class="line">           <span class="comment">// 3.4、获取桶中的key，即类型名称  3.5、获取桶中的文档数量</span></span><br><span class="line">           System.out.println(bucket.getKeyAsString() + <span class="string">"，共"</span> + bucket.getDocCount() + <span class="string">"本"</span>);</span><br><span class="line">           <span class="comment">// 3.6.获取子聚合结果：</span></span><br><span class="line">           InternalAvg avg = (InternalAvg) bucket.getAggregations().asMap().get(<span class="string">"priceAvg"</span>);</span><br><span class="line">           System.out.println(<span class="string">"平均售价："</span> + avg.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文学，共4本</span><br><span class="line">平均售价：141.5</span><br><span class="line">生活，共2本</span><br><span class="line">平均售价：59.0</span><br><span class="line">科幻，共1本</span><br><span class="line">平均售价：99.0</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Spring-Data-Elasticsearch&quot;&gt;&lt;a href=&quot;#Spring-Data-Elasticsearch&quot; cla
      
    
    </summary>
    
      <category term="elasticsearch" scheme="http://yoursite.com/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="http://yoursite.com/tags/elasticsearch/"/>
    
      <category term="spring-data-elasticsearch" scheme="http://yoursite.com/tags/spring-data-elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch优化</title>
    <link href="http://yoursite.com/2019/08/30/es/Elasticsearch%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/"/>
    <id>http://yoursite.com/2019/08/30/es/Elasticsearch优化经验/</id>
    <published>2019-08-29T16:00:00.000Z</published>
    <updated>2019-09-02T09:54:29.561Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --><p>图</p><ul><li>Elasticsearch在数据湖中的地位</li></ul><p><img src="https://i.loli.net/2019/08/12/PV7LqxZHncdzmQ5.jpg" alt="示例"></p><h1 id="1-Elasticsearch部署建议"><a href="#1-Elasticsearch部署建议" class="headerlink" title="1.Elasticsearch部署建议"></a>1.Elasticsearch部署建议</h1><h2 id="1-1选择合理的硬件配置，尽可能使用SSD"><a href="#1-1选择合理的硬件配置，尽可能使用SSD" class="headerlink" title="1.1选择合理的硬件配置，尽可能使用SSD"></a>1.1选择合理的硬件配置，尽可能使用SSD</h2><p>Elasticsearch最大的瓶颈往往是磁盘读写性能，尤其是随机读取性能。使用SSD（PCI-E接口SSD卡/SATA接口SSD盘）通常比机械硬盘（SATA盘/SAS盘）查询速度快5~10倍，写入性能提升不明显。</p><p>对于文档检索类查询性能要求较高的场景，建议考虑SSD作为存储，同时按照1:10的比例配置内存和硬盘。<br>对于日志分析类查询并发要求较低的场景，可以考虑采用机械硬盘作为存储，同时按照1:50的比例配置内存和硬盘。单节点存储数据建议在2TB以内，最大不要超过5TB，避免查询速度慢、系统不稳定。</p><p>在单机存储1TB数据场景下，SATA盘和SSD盘的全文检索性能对比（测试环境：Elasticsearch5.5.3，10亿条人口户籍登记信息，单机16核CPU、64GB内存，12块6TB SATA盘，2块1.5 TB SSD盘）：</p><p>磁盘类型|并发数|QPS|平均检索响应时间|50%请求响应时间|90%请求响应时间|IOPS|<br>—|—|—|—|—|—|—|—|—|—<br>SATA盘|10并发|17|563ms|478ms|994ms|1200<br>SATA盘|50并发|64|773ms|711ms|1155ms|1800<br>SATA盘|100并发|110|902ms|841ms|1225ms|2040<br>SATA盘|200并发|84|2369ms|2335ms|2909ms|2400<br>SSD盘|10并发|94|105ms|90ms|200ms|25400<br>SSD盘|50并发|144|346ms|341ms|411ms|66000<br>SSD盘| 100并发|152|654ms|689ms|791ms|60000<br>SSD盘|200并发|210|950ms|1179ms|1369ms|60000</p><h2 id="1-2-给JVM配置机器一半的内存，但是不建议超过32G"><a href="#1-2-给JVM配置机器一半的内存，但是不建议超过32G" class="headerlink" title="1.2.给JVM配置机器一半的内存，但是不建议超过32G"></a>1.2.给JVM配置机器一半的内存，但是不建议超过32G</h2><p>修改<code>conf/jvm.options</code>配置，<code>-Xms</code>和<code>-Xmx</code>设置为相同的值，推荐设置为机器内存的一半左右，剩余一半留给操作系统缓存使用。</p><p>jvm内存建议不要低于2G，否则有可能因为内存不足导致ES无法正常启动或内存溢出，jvm建议不要超过32G，否则jvm会禁用内存对象指针压缩技术，造成内存浪费。</p><p>机器内存大于64G内存时，推荐配置<code>-Xms30g -Xmx30g</code> 。</p><h2 id="1-3-规模较大的集群配置专有主节点，避免脑裂问题"><a href="#1-3-规模较大的集群配置专有主节点，避免脑裂问题" class="headerlink" title="1.3.规模较大的集群配置专有主节点，避免脑裂问题"></a>1.3.规模较大的集群配置专有主节点，避免脑裂问题</h2><p>Elasticsearch主节点（master节点）负责集群元信息管理、index的增删操作、节点的加入剔除，定期将最新的集群状态广播至各个节点。在集群规模较大时，建议配置专有主节点只负责集群管理，不存储数据，不承担数据读写压力。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">脑裂问题就是集群中出现了多个master，导致集群内部信息混乱，无法对外提供一致信息。</span><br></pre></td></tr></table></figure><blockquote><p>解决方案：避免出现多个master====。====</p><p>根本解决方案：没有。 由于网络原因不可控。</p></blockquote><ul><li><p>关于脑裂的优化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#一个节点多久ping一次，默认1s</span><br><span class="line">discovery.zen.fd.ping_interval: 1s</span><br><span class="line">##等待ping返回时间，默认30s</span><br><span class="line">discovery.zen.fd.ping_timeout: 10s</span><br><span class="line">##ping超时重试次数，默认3次</span><br><span class="line">discovery.zen.fd.ping_retries: 3</span><br><span class="line">##选举时需要的节点连接数</span><br><span class="line">discovery.zen.minimum_master_nodes=N/2+1</span><br></pre></td></tr></table></figure></li><li><p>拓展：Master的选举机制<br><a href="https://blog.csdn.net/xiaoyu_BD/article/details/82016395" target="_blank" rel="noopener">https://blog.csdn.net/xiaoyu_BD/article/details/82016395</a></p></li></ul><h3 id="1-3-1-master节点与data节点分离"><a href="#1-3-1-master节点与data节点分离" class="headerlink" title="1.3.1.master节点与data节点分离"></a>1.3.1.master节点与data节点分离</h3><blockquote><p>配置如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 专有主节点配置(conf/elasticsearch.yml)：</span><br><span class="line">node.master:true</span><br><span class="line">node.data: false</span><br><span class="line">node.ingest:false</span><br><span class="line"></span><br><span class="line"># 数据节点配置(conf/elasticsearch.yml)：</span><br><span class="line">node.master:false</span><br><span class="line">node.data:true</span><br><span class="line">node.ingest:true</span><br></pre></td></tr></table></figure><p>Elasticsearch默认每个节点既是候选主节点，又是数据节点。最小主节点数量参数minimum_master_nodes推荐配置为候选主节点数量一半以上，该配置告诉Elasticsearch当没有足够的master候选节点的时候，不进行master节点选举，等master节点足够了才进行选举。</p><blockquote><p>例如对于3节点集群，最小主节点数量从默认值1改为2。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 最小主节点数量配置(conf/elasticsearch.yml)：</span><br><span class="line">discovery.zen.minimum_master_nodes: 2</span><br></pre></td></tr></table></figure><h3 id="1-3-2-GC算法"><a href="#1-3-2-GC算法" class="headerlink" title="1.3.2.GC算法"></a>1.3.2.GC算法</h3><p>master节点采用(CMS)GC算法，即使GC全局回收，也会及时响应。</p><h3 id="1-3-3-设置discovery-zen-ping-timeout"><a href="#1-3-3-设置discovery-zen-ping-timeout" class="headerlink" title="1.3.3.设置discovery.zen.ping_timeout"></a>1.3.3.设置discovery.zen.ping_timeout</h3><p><code>discovery.zen.ping_timeout（默认3秒）</code>，默认情况下，一个节点会认为，如果master节点在3秒之内没有应答，那么这个节点就是死掉了，而增加这个值，会增加节点等待响应的时间，从一定程度上会减少误判。</p><h3 id="1-3-4-设置选举触发条件"><a href="#1-3-4-设置选举触发条件" class="headerlink" title="1.3.4.设置选举触发条件"></a>1.3.4.设置选举触发条件</h3><p>设置选举触发条件，<code>discovery.zen.minimum_master_nodes:1</code><br>该参数是用于控制选举行为发生的最小集群主节点数量。</p><p>当备选主节点的个数大于等于该参数的值，且备选主节点中有该参数个节点认为主节点挂了，进行选举。</p><p>官方建议为<br><code>（n/2）+1</code>，n为主节点个数（即有资格成为主节点的节点个数），增大该参数，当该值为2时，我们可以设置master的数量为3，这样，挂掉一台，其他两台都认为主节点挂掉了，才进行主节点选举。</p><h3 id="1-3-5-修改data节点的默认的master发现方式"><a href="#1-3-5-修改data节点的默认的master发现方式" class="headerlink" title="1.3.5.修改data节点的默认的master发现方式"></a>1.3.5.修改data节点的默认的master发现方式</h3><p>data节点的默认的master发现方式由multicast修改为unicast</p><p><code>discovery.zen.ping.multicast.enabled: false</code></p><p><code>discovery.zen.ping.unicast.hosts: [&quot;master1&quot;, &quot;master2&quot;, &quot;master3&quot;]</code></p><h2 id="1-4-Linux参数调优"><a href="#1-4-Linux参数调优" class="headerlink" title="1.4.Linux参数调优"></a>1.4.Linux参数调优</h2><blockquote><p>关闭交换分区，防止内存置换降低性能。 将<code>/etc/fstab</code> 文件中包含swap的行注释掉</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.sed -i &apos;/swap/s/^/#/&apos; /etc/fstab</span><br><span class="line">2.swapoff -a</span><br></pre></td></tr></table></figure><blockquote><p>单用户可以打开的最大文件数量，可以设置为官方推荐的65536或更大些</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;* - nofile 655360&quot; &gt;&gt; /etc/security/limits.conf</span><br></pre></td></tr></table></figure><blockquote><p>单用户内存地址空间</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;* - as unlimited&quot;&gt;&gt; /etc/security/limits.conf</span><br></pre></td></tr></table></figure><blockquote><p>单用户文件大小</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;* - fsize unlimited&quot; &gt;&gt;/etc/security/limits.conf</span><br></pre></td></tr></table></figure><blockquote><p>单用户锁定内存</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;* - memlock unlimited&quot; &gt;&gt;/etc/security/limits.conf</span><br></pre></td></tr></table></figure><blockquote><p>单用户线程数调大</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;* - nproc 131072&quot; &gt;&gt; /etc/security/limits.conf</span><br></pre></td></tr></table></figure><blockquote><p>单进程可以使用的最大map内存区域数量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;vm.max_map_count = 655360&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><blockquote><p>参数修改立即生效</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><blockquote><p>降低tcp alive time，防止无效链接占用链接数</p></blockquote><h2 id="1-5-参数调优"><a href="#1-5-参数调优" class="headerlink" title="1.5.参数调优"></a>1.5.参数调优</h2><p>开启内存锁，禁止swapping<br>执行linux命令(临时生效)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -l unlimited</span><br></pre></td></tr></table></figure><p>修改主机配置：/etc/security/limits.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft memlock unlimited</span><br><span class="line">* hard memlock unlimited</span><br></pre></td></tr></table></figure><blockquote><p>修改es配置：config/elasticsearch.yml</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.memory_lock : true</span><br></pre></td></tr></table></figure><ul><li>调大文件描述符数量<blockquote><p>执行linux命令(临时生效)</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n 65535</span><br></pre></td></tr></table></figure><blockquote><p>修改linux配置文件：/etc/security/limits.conf</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br></pre></td></tr></table></figure><ul><li>调大最大映射数<blockquote><p>执行linux命令(临时生效)</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure><blockquote><p>修改linux配置文件：/etc/sysctl.conf</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count=262144</span><br></pre></td></tr></table></figure><h2 id="1-6-JVM内存溢出处理"><a href="#1-6-JVM内存溢出处理" class="headerlink" title="1.6.JVM内存溢出处理"></a>1.6.JVM内存溢出处理</h2><p>防止es节点内存溢出后处于僵死状态且无法恢复，影响整个集群，在进程出现OOM时让进程宕掉，退出ES集群并引发告警，然后重启。</p><p>在config/jvm.options中增加JVM启动参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+ExitOnOutOfMemoryError</span><br></pre></td></tr></table></figure><p>==该参数在jdk 1.8.0_92版本上线==</p><h2 id="1-7-GC调优"><a href="#1-7-GC调优" class="headerlink" title="1.7.GC调优"></a>1.7.GC调优</h2><p>ElasticSearch本质上是个Java程序，所以配置JVM垃圾回收器本身也是一个很有意义的工作。我们使用JVM的Xms和Xmx参数来提供指定内存大小，本质上提供的是JVM的堆空间大小，当JVM的堆空间不足的时候就会触发致命的OutOfMemoryException。这意味着要么内存不足，要么出现了内存泄露。处理GC问题，首先要确定问题的源头，一般有两种方案：</p><ol><li><p>开启ElasticSearch上的GC日志</p></li><li><p>使用jstat命令</p></li><li><p>生成内存Dump</p></li></ol><p>关于第一条，在ES的配置文件elasticsearch.yml中有相关的属性可以配置，关于每个属性的用途这里当然说不完。</p><p>第二条，jstat命令可以帮助我们查看JVM堆中各个区的使用情况和GC的耗时情况。</p><p>第三条，最后的办法就是将JVM的堆空间转储到文件中去，实质上是对JVM堆空间的一个快照。</p><p>想了解更多关于JVM本身GC调优方法请参考：<a href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html" target="_blank" rel="noopener">link</a></p><p>另外，通过修改ES节点的启动参数，也可以调整GC的方式，但是实质上和上述方法是等同的。</p><h1 id="2-索引性能调优建议"><a href="#2-索引性能调优建议" class="headerlink" title="2.索引性能调优建议"></a>2.索引性能调优建议</h1><h2 id="2-1-设置合理的索引分片数和副本数"><a href="#2-1-设置合理的索引分片数和副本数" class="headerlink" title="2.1.设置合理的索引分片数和副本数"></a>2.1.设置合理的索引分片数和副本数</h2><p>索引分片数建议设置为集群节点的整数倍，初始数据导入时副本数设置为0，生产环境副本数建议设置为1（设置1个副本，集群任意1个节点宕机数据不会丢失；设置更多副本会占用更多存储空间，操作系统缓存命中率会下降，检索性能不一定提升）。</p><p>单节点索引分片数建议不要超过3个，每个索引分片推荐10-40GB大小。索引分片数设置后不可以修改，副本数设置后可以修改。</p><p>Elasticsearch6.X及之前的版本默认索引分片数为5、副本数为1，从Elasticsearch7.0开始调整为默认索引分片数为1、副本数为1。</p><p>不同分片数对写入性能的影响（测试环境：7节点Elasticsearch6.3集群，写入30G新闻数据，单节点56核CPU、380G内存、3TB SSD卡，0副本，20线程写入，每批次提交10M左右数据。）：</p><p>集群索引分片数|单节点索引分片数|写入耗时|<br>—|—|—|—|—|—|—|—<br>2|0/1|600s<br>7|1|327s<br>14|2|258s<br>21|3|211s<br>28|4|211s<br>56|8|214s</p><blockquote><p>索引设置</p></blockquote><figure class="highlight plain"><figcaption><span>-XPUT</span><a href="http://localhost:9200/fulltext001?pretty" target="_blank" rel="noopener">-H 'Content-Type: application/json' -d '</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot; : &#123;</span><br><span class="line">      &quot;refresh_interval&quot;: &quot;30s&quot;,</span><br><span class="line">      &quot;merge.policy.max_merged_segment&quot;: &quot;1000mb&quot;,</span><br><span class="line">      &quot;translog.durability&quot;: &quot;async&quot;,</span><br><span class="line">      &quot;translog.flush_threshold_size&quot;: &quot;2gb&quot;,</span><br><span class="line">      &quot;translog.sync_interval&quot;: &quot;100s&quot;,</span><br><span class="line">      &quot;index&quot; : &#123;</span><br><span class="line">        &quot;number_of_shards&quot; : &quot;21&quot;,</span><br><span class="line">        &quot;number_of_replicas&quot; : &quot;0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>mapping设置：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> curl -XPOST http://localhost:9200/fulltext001/doc/_mapping?pretty  -H &apos;Content-Type: application/json&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;doc&quot; : &#123;</span><br><span class="line">        &quot;_all&quot; : &#123;</span><br><span class="line">            &quot;enabled&quot; : false</span><br><span class="line">         &#125;,</span><br><span class="line">        &quot;properties&quot; : &#123;</span><br><span class="line">          &quot;content&quot; : &#123;</span><br><span class="line">            &quot;type&quot; : &quot;text&quot;,</span><br><span class="line">            &quot;analyzer&quot;:&quot;ik_max_word&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;id&quot; : &#123;</span><br><span class="line">            &quot;type&quot; : &quot;keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>curl -XPUT “<a href="http://localhost:9200/fulltext001/_settings&quot;" target="_blank" rel="noopener">http://localhost:9200/fulltext001/_settings&quot;</a> -H ‘Content-Type: application/json’ -d’<br>{<br>“number_of_replicas”: 1<br>}</p><h2 id="2-2-使用批量请求"><a href="#2-2-使用批量请求" class="headerlink" title="2.2.使用批量请求"></a>2.2.使用批量请求</h2><h3 id="2-2-1-考虑"><a href="#2-2-1-考虑" class="headerlink" title="2.2.1 考虑"></a>2.2.1 考虑</h3><p>如果你在做大批量导入，考虑通过设置 <code>index.number_of_replicas: 0</code>关闭副本。</p><p>把每个索引的 <code>index.refresh_interval</code>改到 -1关闭刷新。导入完毕后再开启副本和刷新。</p><h3 id="2-2-2-说明"><a href="#2-2-2-说明" class="headerlink" title="2.2.2 说明"></a>2.2.2 说明</h3><p>使用批量请求将产生比单文档索引请求好得多的性能。写入数据时调用批量提交接口，推荐每批量提交5~15MB数据。例如单条记录1KB大小，每批次提交10000条左右记录写入性能较优；单条记录5KB大小，每批次提交2000条左右记录写入性能较优。</p><blockquote><p>批量请求接口API：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST &quot;http://localhost:9200/_bulk&quot; -H &apos;Content-Type: application/json&apos; -d&apos;</span><br><span class="line">&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;test&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;field1&quot; : &quot;value1&quot; &#125;</span><br><span class="line">&#123; &quot;delete&quot; : &#123; &quot;_index&quot; : &quot;test&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;create&quot; : &#123; &quot;_index&quot; : &quot;test&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;3&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;field1&quot; : &quot;value3&quot; &#125;</span><br><span class="line">&#123; &quot;update&quot; : &#123;&quot;_id&quot; : &quot;1&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_index&quot; : &quot;test&quot;&#125; &#125;</span><br><span class="line">&#123; &quot;doc&quot; : &#123;&quot;field2&quot; : &quot;value2&quot;&#125; &#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-通过多进程-线程发送数据"><a href="#2-3-通过多进程-线程发送数据" class="headerlink" title="2.3.通过多进程/线程发送数据"></a>2.3.通过多进程/线程发送数据</h2><p>单线程批量写入数据往往不能充分利用服务器CPU资源，可以尝试调整写入线程数或者在多个客户端上同时向Elasticsearch服务器提交写入请求。与批量调整大小请求类似，只有测试才能确定最佳的worker数量。</p><p>可以通过逐渐增加工作任务数量来测试，直到集群上的I / O或CPU饱和。</p><h2 id="2-4-调大refresh-interval"><a href="#2-4-调大refresh-interval" class="headerlink" title="2.4.调大refresh interval"></a>2.4.调大refresh interval</h2><p>在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做 refresh 。 默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch 是近实时搜索:<br>文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。</p><p>并不是所有的情况都需要每秒刷新。可能你正在使用 Elasticsearch 索引大量的日志文件，你可能想优化索引速度而不是近实时搜索，可以通过设置 <code>refresh_interval</code>，降低每个索引的刷新频率。</p><p>设置<code>refresh interval</code> API:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT &quot;http://localhost:9200/index&quot; -H &apos;Content-Type: application/json&apos; -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot; : &#123;</span><br><span class="line">      &quot;refresh_interval&quot;: &quot;30s&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>refresh_interval</code> 可以在既存索引上进行动态更新。 在生产环境中，当你正在建立一个大的新索引时，可以先关闭自动刷新，待开始使用该索引时，再把它们调回来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT &quot;http://localhost:9200/index/_settings&quot; -H &apos;Content-Type: application/json&apos; -d&apos;</span><br><span class="line">&#123; &quot;refresh_interval&quot;: -1 &#125;&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT &quot;http://localhost:9200/index/_settings&quot; -H &apos;Content-Type: application/json&apos; -d&apos;</span><br><span class="line">&#123; &quot;refresh_interval&quot;: &quot;1s&quot; &#125;&apos;</span><br></pre></td></tr></table></figure><h2 id="2-5-设计mapping配置合适的字段类型"><a href="#2-5-设计mapping配置合适的字段类型" class="headerlink" title="2.5.设计mapping配置合适的字段类型"></a>2.5.设计mapping配置合适的字段类型</h2><p>Elasticsearch在写入文档时，如果请求中指定的索引名不存在，会自动创建新索引，并根据文档内容猜测可能的字段类型。但这往往不是最高效的，我们可以根据应用场景来设计合理的字段类型。</p><p>例如写入一条记录：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> curl -XPUT &quot;http://localhost:9200/twitter/doc/1?pretty&quot; -H &apos;Content-Type: application/json&apos; -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;user&quot;: &quot;kimchy&quot;,</span><br><span class="line">    &quot;post_date&quot;: &quot;2009-11-15T13:12:00&quot;,</span><br><span class="line">    &quot;message&quot;: &quot;Trying out Elasticsearch, so far so good?&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>查询Elasticsearch自动创建的索引mapping，会发现将<code>post_date</code>字段自动识别为date类型，但是message和user字段被设置为text、keyword冗余字段，造成写入速度降低、占用更多磁盘空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &quot;http://localhost:9200/twitter&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;twitter&quot;: &#123;</span><br><span class="line">    &quot;mappings&quot;: &#123;</span><br><span class="line">      &quot;doc&quot;: &#123;</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">          &quot;message&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">            &quot;fields&quot;: &#123;</span><br><span class="line">              &quot;keyword&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">                &quot;ignore_above&quot;: 256</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;post_date&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;date&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;user&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">            &quot;fields&quot;: &#123;</span><br><span class="line">              &quot;keyword&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">                &quot;ignore_above&quot;: 256</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">      &quot;index&quot;: &#123;</span><br><span class="line">        &quot;number_of_shards&quot;: &quot;5&quot;,</span><br><span class="line">        &quot;number_of_replicas&quot;: &quot;1&quot;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据业务场景设计索引配置合理的分片数、副本数，设置字段类型、分词器。如果不需要合并全部字段，禁用<code>_all</code>字段，通过<code>copy_to</code>来合并字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> curl -XPUT &quot;http://localhost:9200/twitter?pretty&quot; -H &apos;Content-Type: application/json&apos; -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot; : &#123;</span><br><span class="line">      &quot;index&quot; : &#123;</span><br><span class="line">        &quot;number_of_shards&quot; : &quot;20&quot;,</span><br><span class="line">        &quot;number_of_replicas&quot; : &quot;0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST &quot;http://localhost:9200/twitter/doc/_mapping?pretty&quot; -H &apos;Content-Type: application/json&apos; -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;doc&quot; : &#123;</span><br><span class="line">        &quot;_all&quot; : &#123;</span><br><span class="line">        &quot;enabled&quot; : false</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;properties&quot; : &#123;</span><br><span class="line">          &quot;user&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;keyword&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;post_date&quot; : &#123;</span><br><span class="line">            &quot;type&quot; : &quot;date&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;message&quot; : &#123;</span><br><span class="line">            &quot;type&quot; : &quot;text&quot;,</span><br><span class="line">            &quot;analyzer&quot; : &quot;cjk&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-索引配置"><a href="#2-6-索引配置" class="headerlink" title="2.6.索引配置"></a>2.6.索引配置</h2><ul><li><p><code>settings:{efresh_interval}</code>：数据写入刷新间隔，默认1s，调整增加该值可以减少写入压力、增加写入速度，如设为60</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;settings&quot;: &#123;</span><br><span class="line">  &quot;refresh_interval&quot;: &quot;60s&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>mappings:{dynamic}</code>： 禁止es自动创建字段，仅允许预先设定好的字段存入es，防止索引结构混乱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;mappings&quot;: &#123;</span><br><span class="line">   &quot;mytype&quot;: &#123;</span><br><span class="line">     &quot;dynamic&quot;: false</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>all</code>：建议禁用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;_all&quot;: &#123;</span><br><span class="line">   &quot;enable&quot;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>keyword</code>字段属性: ingore_above超过多少字符不写入，keyword一般用于精确查询，不能写入太长。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">    &quot;ingore_above&quot;: 1000</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>index</code>属性：将 不作为查询字段的index值设为false</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;content&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">      &quot;index&quot;: &quot;false&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-查询性能调优建议"><a href="#3-查询性能调优建议" class="headerlink" title="3.查询性能调优建议"></a>3.查询性能调优建议</h1><h2 id="3-1-使用过滤器缓存和分片查询缓存"><a href="#3-1-使用过滤器缓存和分片查询缓存" class="headerlink" title="3.1.使用过滤器缓存和分片查询缓存"></a>3.1.使用过滤器缓存和分片查询缓存</h2><p>ES中的查询操作分为2种：查询（query）和过滤（filter），查询默认会计算每个返回文档的得分，然后根据得分排序；而过滤（filter）只会筛选出符合的文档，并不计算得分，且它可以缓存文档。单从性能考虑，过滤比查询更快而且更节省io资源。过滤适合在大范围筛选数据，而查询则适合精确匹配数据。开发时应先使用过滤操作过滤数据，然后使用查询匹配数据</p><p>默认情况下，Elasticsearch的查询会计算返回的每条数据与查询语句的相关度，但对于非全文索引的使用场景，用户并不关心查询结果与查询条件的相关度，只是想精确的查找目标数据。此时，可以通过filter来让Elasticsearch不计算评分，并且尽可能的缓存filter的结果集，供后续包含相同filter的查询使用，提高查询效率。</p><p>普通查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &quot;http://localhost:9200/twitter/_search&quot; -H &apos;Content-Type: application/json&apos; -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;user&quot;: &quot;kimchy&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤器(filter)查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &quot;http://localhost:9200/twitter/_search&quot; -H &apos;Content-Type: application/json&apos; -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">         &quot;match&quot;: &#123;</span><br><span class="line">          &quot;user&quot;: &quot;kimchy&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分片查询缓存的目的是缓存聚合、提示词结果和命中数（它不会缓存返回的文档，因此，它只在<code>search_type=count</code>时起作用）。</p><p>通过下面的参数我们可以设置分片缓存的大小，默认情况下是JVM堆的1%大小，当然我们也可以手动设置在<code>config/elasticsearch.yml</code>文件里:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indices.requests.cache.size: 1%</span><br></pre></td></tr></table></figure><p>查看缓存占用内存情况(<code>name</code>表示节点名, <code>query_cache</code>表示过滤器缓存，<code>request_cache</code>表示分片缓存，fielddata表示字段数据缓存，<code>segments</code>表示索引段)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &quot;http://localhost:9200/_cat/nodes?h=name,query_cache.memory_size,request_cache.memory_size,fielddata.memory_size,segments.memory&amp;v&quot;</span><br></pre></td></tr></table></figure><h2 id="3-2-使用路由routing"><a href="#3-2-使用路由routing" class="headerlink" title="3.2.使用路由routing"></a>3.2.使用路由routing</h2><h3 id="3-2-1-概念"><a href="#3-2-1-概念" class="headerlink" title="3.2.1.概念"></a>3.2.1.概念</h3><p>在将数据写入es时，指定一个字段作为路由字段，es会将该字段进行hash计算写入到对应的分片上；查询时根据查询条件中的路由值，直接查找所在的分片，大幅度提高查询速度。</p><p>需要注意的是：路由字段必须是随机分布，否则会导致分片数据不平均引发的主机存储使用不平均，可以作为路由字段的：如业务流水、省份、系统编码等。</p><h3 id="3-2-2-说明"><a href="#3-2-2-说明" class="headerlink" title="3.2.2.说明"></a>3.2.2.说明</h3><p>Elasticsearch写入文档时，文档会通过一个公式路由到一个索引中的一个分片上。默认的公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shard_num = hash(_routing) % num_primary_shards</span><br></pre></td></tr></table></figure><p><code>_routing</code>字段的取值，默认是_id字段，可以根据业务场景设置经常查询的字段作为路由字段。例如可以考虑将用户id、地区作为路由字段，查询时可以过滤不必要的分片，加快查询速度。</p><blockquote><p>写入时指定路由：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT &quot;http://localhost:9200/my_index/my_type/1?routing=user1&quot; -H &apos;Content-Type: application/json&apos; -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;This is a document&quot;,</span><br><span class="line">  &quot;author&quot;: &quot;user1&quot;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><blockquote><p>查询时不指定路由，需要查询所有分片：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &quot;http://localhost:9200/my_index/_search&quot; -H &apos;Content-Type: application/json&apos; -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &quot;document&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>返回结果：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;: 2,</span><br><span class="line">  &quot;timed_out&quot;: false,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 5,</span><br><span class="line">    &quot;successful&quot;: 5,</span><br><span class="line">    &quot;skipped&quot;: 0,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询时指定路由，只需要查询1个分片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &quot;http://localhost:9200/my_index/_search?routing=user1&quot; -H &apos;Content-Type: application/json&apos; -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &quot;document&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>返回结果：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;: 1,</span><br><span class="line">  &quot;timed_out&quot;: false,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 1,</span><br><span class="line">    &quot;successful&quot;: 1,</span><br><span class="line">    &quot;skipped&quot;: 0,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-强制合并只读索引，关闭历史数据索引"><a href="#3-3-强制合并只读索引，关闭历史数据索引" class="headerlink" title="3.3.强制合并只读索引，关闭历史数据索引"></a>3.3.强制合并只读索引，关闭历史数据索引</h2><p>只读的索引可以从合并成一个单独的大segment中收益，减少索引碎片，减少JVM堆常驻内存。历史数据索引如果业务上不再支持查询请求，可以考虑关闭索引，减少JVM内存占用。</p><blockquote><p>索引 <code>forcemerge</code> API:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST &quot;http://localhost:9200/abc20180923/_forcemerge&quot;</span><br></pre></td></tr></table></figure><blockquote><p>索引关闭API:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST &quot;http://localhost:9200/abc2017*/_close&quot;</span><br></pre></td></tr></table></figure><h2 id="3-4-配置查询聚合节点"><a href="#3-4-配置查询聚合节点" class="headerlink" title="3.4.配置查询聚合节点"></a>3.4.配置查询聚合节点</h2><p>查询聚合节点可以发送粒子查询请求到其他节点，收集和合并结果，以及响应发出查询的客户端。通过给查询聚合节点配置更高规格的CPU和内存，可以加快查询运算速度、提升缓存命中率。</p><p>某客户使用25台8核CPU32G内存节点ELasticsearch集群，查询QPS在4000左右。增加6台16核CPU32G内存节点作为查询聚合节点，观察服务器CPU、JVM堆内存使用情况，并调整缓存、分片、副本参数，查询QPS达到12000。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查询聚合节点配置(conf/elasticsearch.yml)：</span><br><span class="line">node.master: false</span><br><span class="line">node.data: false</span><br><span class="line">node.ingest:false</span><br></pre></td></tr></table></figure><h2 id="3-5-设置查询读取记录条数和字段"><a href="#3-5-设置查询读取记录条数和字段" class="headerlink" title="3.5.设置查询读取记录条数和字段"></a>3.5.设置查询读取记录条数和字段</h2><h3 id="3-5-1-避免深分页查询"><a href="#3-5-1-避免深分页查询" class="headerlink" title="3.5.1.避免深分页查询"></a>3.5.1.避免深分页查询</h3><p>ES集群的分页查询支持from和size参数，查询的时候，每个分片必须构造一个长度为from+size的优先队列，然后回传到网关节点，网关节点再对这些优先队列进行排序找到正确的size个文档。</p><p>假设在一个有6个主分片的索引中，from为10000，size为10，每个分片必须产生10010个结果，在网关节点中汇聚合并60060个结果，最终找到符合要求的10个文档。</p><p>由此可见，当from足够大的时候，就算不发生OOM，也会影响到CPU和带宽等，从而影响到整个集群的性能。所以应该避免深分页查询，尽量不去使用。</p><h3 id="3-5-2-示例"><a href="#3-5-2-示例" class="headerlink" title="3.5.2.示例"></a>3.5.2.示例</h3><p>限制是为了保证es集群的稳定性。限制的内容包括：查询范围、单次查询数量等，过大的查询范围不仅会导致查询效率低，而且会是es集群资源耗费急剧增加，甚至引起es集群崩溃；单次查询数量限制是为了保证内存不会被查询内存大量占用，就是分页原理，es默认可以查询10000条数据。</p><p>默认的查询请求通常返回排序后的前10条记录，最多一次读取10000条记录，通过from和size参数控制读取记录范围，避免一次读取过多的记录。通过_source参数可以控制返回字段信息，尽量避免读取大字段。</p><blockquote><p>查询请求示例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET http://localhost:9200/fulltext001/_search?pretty  -H &apos;Content-Type: application/json&apos; -d &apos; </span><br><span class="line">&#123;</span><br><span class="line">  &quot;from&quot;: 0,</span><br><span class="line">  &quot;size&quot;: 10,</span><br><span class="line">  &quot;_source&quot;: &quot;id&quot;,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;&quot;match&quot;: &#123;&quot;content&quot;:&quot;xxx&quot;&#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;asc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-避免前缀模糊匹配"><a href="#3-6-避免前缀模糊匹配" class="headerlink" title="3.6.避免前缀模糊匹配"></a>3.6.避免前缀模糊匹配</h2><p>Elasticsearch默认支持通过*?正则表达式来做模糊匹配，如果在一个数据量超过10亿条的索引上执行模糊匹配，尤其是前缀模糊匹配，通常耗时会比较长，甚至可能导致内存溢出。尽量避免在高并发查询请求的生产环境执行这类操作。</p><p>某客户需要对车牌号进行模糊查询，通过查询请求”车牌号:<em>A8848</em>“查询时，往往导致整个集群负载较高。通过对数据预处理，增加冗余字段”车牌号.keyword”，并事先将所有车牌号按照1元、2元、3元…7元分词后存储至该字段，字段存储内容示例:沪,A,8,4,沪A,A8,88,84,48,沪A8…沪A88488。通过查询”车牌号.keyword:A8848”即可解决原来的性能问题。</p><h2 id="3-7-避免索引稀疏"><a href="#3-7-避免索引稀疏" class="headerlink" title="3.7.避免索引稀疏"></a>3.7.避免索引稀疏</h2><p>Elasticsearch6.X之前的版本默认允许在一个index下面创建多个type，Elasticsearch6.X及之后的版本只允许创建一个type。在一个type下面创建多个字段不一样的type，或者将几百个字段不一样的索引合并到一个索引中，会导致索引稀疏问题。</p><p>对于索引优化可以提前创建索引，避免索引稀疏，index中的document结构最好保持一致，如果document结构不一致，建议分index，用一个少量shard的index存放field格式不同的document。</p><p>建议每个索引下只创建一个type，字段不一样的数据分别独立创建index，不要合并成一个大索引。每个查询请求根据需要去读取相应的索引，避免查询大索引扫描全部记录，加快查询速度。</p><blockquote><p>扩展：</p></blockquote><p>在加载大量数据使<code>refresh_interval=-1</code>，<code>index.number_of_replicas=0</code>，索引完成后再设回来。Laod和IO压力不大的情况下，用<code>bulk</code>比单条的<code>PUT/DELETE</code>操作索引效率更高。</p><p>调整<code>index buffer</code>的大小，若不需要<code>field</code>的打分，则可以禁用<code>norms</code>；同样的若不需要<code>sort</code>或<code>aggregate</code>的<code>field</code>，则可以把<code>doc_value</code>属性禁用。</p><p>对于查询优化可以使用routing提升一维度数的查询速度；通过limit限制，避免返回太大量的搜索结果集；如果heap压力不大，可适当增加<code>node query cache</code>；增加shard备份可提高查询并发能力，但要注意node上的shard总量；最后是定期合并segment。</p><h2 id="3-8-扩容集群节点个数、升级节点规格"><a href="#3-8-扩容集群节点个数、升级节点规格" class="headerlink" title="3.8.扩容集群节点个数、升级节点规格"></a>3.8.扩容集群节点个数、升级节点规格</h2><p>通常服务器节点数越多，服务器硬件配置规格越高，Elasticsearch集群的处理能力越强。</p><p>在不同节点规模下的查询性能测试（测试环境：Elasticsearch5.5.3集群，单节点16核CPU、64G内存、2T SSD盘，10亿条人口户籍登记信息，数据大小1TB。）：</p><p>集群节点数|副本数|10并发检索平均响应时间|50并发检索平均响应时间|100并发检索平均响应时间|200并发检索平均响应时间|200并发QPS|200并发CPU使用率|200并发CPU IO等待|<br>—|—|—|—|—|—|—|—|—|—<br>1|0|77ms|459ms|438ms|1001ms|200|16%|52%<br>3|0|38ms|103ms|162ms|298ms|669|45%|34%|<br>3|2|271ms|356ms|577ms|818ms|244|19%|54%|<br>10|0|21ms|36ms|48ms|81ms|2467|40%|10%|</p><p>不同集群节点规模写入性能测试（测试环境：Elasticsearch6.3.2集群，单节点16核CPU、64G内存、2T SSD盘，10亿条人口户籍登记信息，单条记录1KB，数据集大小1TB，20个并发写入线程。）：<br>集群节点数|副本数|写入TPS|耗时|集群CPU使用率|<br>—|—|—|—|—|—|—|—|—|—<br>10|0|88945|11242s|50%<br>50|0|180638|5535s|20%</p><h2 id="3-9-数据生命周期"><a href="#3-9-数据生命周期" class="headerlink" title="3.9.数据生命周期"></a>3.9.数据生命周期</h2><p>es中的开启状态的索引都会占用堆内存来存储倒排索引，过多的索引会导致集群整体内存使用率多大，甚至引起内存溢出。所以需要根据自身业务管理历史数据的生命周期，如近3个月的数据开启用于快速查询；过去3-6月的数据索引关闭以释放内存，需要时再开启；超过6个月的可以生成快照保存至hdfs并删除索引，需要的时候从hdfs选择需要的索引恢复至集群中进行查询</p><p>生产上常常使用logstash+索引模板的方式按照一定时间创建新的索引，例如按天创建索引，索引的命名可能是index-yyyy-mm-dd，每天生产不同的索引，清除历史数据时可直接关闭或删除</p><p>需要注意的是：如何按照logstash默认的时间分割索引会有8个小时的误差，所以需要在logstash中将真实数据中的时间字段作为分割条件，保障按照业务时间分割索引</p><h1 id="4-实时性要求高的查询走DB"><a href="#4-实时性要求高的查询走DB" class="headerlink" title="4.实时性要求高的查询走DB"></a>4.实时性要求高的查询走DB</h1><p>对于ES写入机制的有了解的同学可能会知道，新增的文档会被收集到<code>Indexing Buffer</code>，然后写入到文件系统缓存中，到了文件系统缓存中就可以像其他的文件一样被索引到。</p><p>然而默认情况文档从<code>Indexing Buffer</code>到文件系统缓存（即<code>Refresh</code>操作）是每秒分片自动刷新，所以这就是我们说ES是==近实时搜索==而非实时的原因：文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。</p><p>举例：当前订单系统ES采用的是默认Refresh配置，故对于那些订单数据实时性比较高的业务，直接走数据库查询，保证数据的准确性。</p><h1 id="5-ES-查询耗时很长，响应时间过久，该怎么做（类比mysql执行计划分析）"><a href="#5-ES-查询耗时很长，响应时间过久，该怎么做（类比mysql执行计划分析）" class="headerlink" title="5. ES 查询耗时很长，响应时间过久，该怎么做（类比mysql执行计划分析）"></a>5. ES 查询耗时很长，响应时间过久，该怎么做（类比mysql执行计划分析）</h1><p>包含但不限于：Nested慢查询、集群查询慢、range查询慢等问题。</p><p>1）可以用 profile 来查看具体是哪里执行慢<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-profile.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-profile.html</a></p><p>2）能用 filter 的都用 filter，减少打分的查询，比如你 must 里面的很多都是可以用 filter 来做的，根据上面的文档来优化。</p><blockquote><p>两个维度</p></blockquote><p>每当我们得到这些类型的问题时，我们首先要深入研究两个主要方面：</p><ul><li>配置维度 - 查看当前系统资源和默认Elasticsearch选项。</li><li>开发维度 - 查看查询，其结构以及要搜索的数据的映射（Mapping）。</li></ul><p>我们将首先关注开发方面的问题。 我们将获得慢查询，讨论DSL查询语言，并查看有助于改进Elasticsearch查询的小型常规选项。</p><blockquote><p>日志</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1[2018-05-21T12:35:53,352][DEBUG ][index.search.slowlog.query] </span><br><span class="line">2[DwOfjJF] [blogpost-slowlogs][4] took[1s], took_millis[0], types[], </span><br><span class="line">3stats[], search_type[QUERY_THEN_FETCH], total_shards[5], </span><br><span class="line">4source[&#123;&quot;query&quot;:&#123;&quot;match&quot;:&#123;&quot;name&quot;:&#123;&quot;query&quot;:&quot;hello world&quot;,</span><br><span class="line">5 &quot;operator&quot;:&quot;OR&quot;,&quot;prefix_length&quot;:0,&quot;max_expansions&quot;:50,</span><br><span class="line">6&quot;fuzzy_transpositions&quot; :true,&quot;lenient&quot;:false,&quot;zero_terms_query&quot;:</span><br><span class="line">7 &quot;NONE&quot;,&quot;boost&quot;:1.0&#125;&#125;&#125;,&quot;sort&quot;:[&#123;&quot;price&quot;: &#123;&quot;order&quot;:&quot;desc&quot;&#125;&#125;]&#125;],</span><br></pre></td></tr></table></figure><blockquote><p>通过分解的日志可以看到</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 日期</span><br><span class="line">2 时间戳 </span><br><span class="line">3 日志级别 </span><br><span class="line">4 慢速类型 </span><br><span class="line">5 节点名称 </span><br><span class="line">6 索引名称 </span><br><span class="line">7 分片号 </span><br><span class="line">8 时间花费 </span><br><span class="line">9 查询的主体（_source&gt;）</span><br></pre></td></tr></table></figure><p>一旦我们获得了我们认为花费的时间太长的查询，我们就可以使用一些工具来分解查询：</p><ul><li>工具1：Profile API</li></ul><p>Profile API提供有关搜索的信息页面，并分解每个分片中发生的情况，直至每个搜索组件（match/range/match_phrase等）的各个时间。 搜索越详细，_profile输出越详细。</p><ul><li>工具2：Kibana profiling 工具</li></ul><p>这与_profileAPI密切相关。 它提供了各个搜索组件的完美的可视化效果表征各个分解阶段以及各阶段查询的时间消耗。 同样，这可以轻松选择查询的问题区域。</p><p>摘自 : <a href="https://cloud.tencent.com/developer/article/1357698" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1357698</a></p><h1 id="6-OP关注"><a href="#6-OP关注" class="headerlink" title="6.OP关注"></a>6.OP关注</h1><p>运维Elasticsearch集群主要关注一下几个方面：</p><ul><li>集群健康状态。</li><li>集群索引和搜索性能。</li><li>节点CPU、memory以及disk的使用情况。</li><li>集群健康状态分为三种，集群green代表健康，集群yellow主要是有replica shard未分配，但不影响集群正常使用，集群red主要是因为有primary shard未分配，会影响集群正常使用。主要原因是集群node disk使用率超过默认值85%，这样一来新的shard就无法分配。这种情况可以通过以下方式查看：<ul><li>通过api GET/_cat/allocation查看node的磁盘使用率。</li><li>通过api GET/_cluster/settings查看<br>cluster.routing.allocation.enable是否被禁止。</li><li>通过api GET/_cluster/allocation/explain?pretty查看shard未分配到node的具体原因。</li></ul></li></ul><hr><p>参考：</p><p>Elasticsearch参考[7.3] »如何 »调整搜索速度<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/tune-for-search-speed.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/tune-for-search-speed.html</a> 等<br>Organized from <a href="https://elasticsearch.cn/" target="_blank" rel="noopener">https://elasticsearch.cn/</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;图&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Elasticsearch在数据湖中的地位&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.
      
    
    </summary>
    
      <category term="elasticsearch" scheme="http://yoursite.com/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="http://yoursite.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch（一）</title>
    <link href="http://yoursite.com/2019/08/30/es/Elasticsearch(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/08/30/es/Elasticsearch(一)/</id>
    <published>2019-08-29T16:00:00.000Z</published>
    <updated>2019-09-02T08:44:23.952Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>大规模数据的检索解决查询瓶颈和写入瓶颈</p><ul><li>传统数据库<blockquote><ul><li>a. 通过主从备份解决数据安全性问题</li><li>b. 通过数据库代理中间件心跳监测，解决单点故障问题</li><li>c. 通过代理中间件将查询语句分发到各个slave节点进行查询，并汇总结果</li></ul></blockquote></li><li>非关系型数据库<blockquote><ul><li>对于Nosql数据库，以mongodb为例，其它原理类似：</li><li>a. 通过副本备份保证数据安全性</li><li>b. 通过节点竞选机制解决单点问题</li><li>c. 先从配置库检索分片信息，然后将请求分发到各个节点，最后由路由节点合并汇总结果</li></ul></blockquote></li><li>方案<blockquote><ul><li>存储数据时按有序存储</li><li>将数据和索引分离</li><li>压缩数据</li><li>———————–引出es————————–</li></ul></blockquote></li></ul><h1 id="1-Elasticsearch介绍和安装"><a href="#1-Elasticsearch介绍和安装" class="headerlink" title="1.Elasticsearch介绍和安装"></a>1.Elasticsearch介绍和安装</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1.简介"></a>1.1.简介</h2><h3 id="1-1-1-Elastic"><a href="#1-1-1-Elastic" class="headerlink" title="1.1.1.Elastic"></a>1.1.1.Elastic</h3><p><a href="https://www.elastic.co/cn/" target="_blank" rel="noopener">Elastic官网</a></p><p>Elastic有一条完整的产品线及解决方案：Elasticsearch、Kibana、Logstash等，前面说的三个就是大家常说的ELK技术栈。</p><ul><li>elasticsearch：后台分布式存储以及全文检索</li><li>logstash: 日志加工、“搬运工”</li><li>kibana：数据可视化展示。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ELK架构为数据分布式存储、可视化查询和日志解析创建了一个功能强大的管理链。 三者相互配合，取长补短，共同完成分布式大数据处理工作。</span><br></pre></td></tr></table></figure><h3 id="1-1-2-Elasticsearch"><a href="#1-1-2-Elasticsearch" class="headerlink" title="1.1.2.Elasticsearch"></a>1.1.2.Elasticsearch</h3><p><a href="https://www.elastic.co/cn/products/elasticsearch" target="_blank" rel="noopener">Elasticsearch官网</a></p><p>ElasticSearch 的实现原理主要分为以下几个步骤，首先用户将数据提交到Elastic Search 数据库中，再通过分词控制器去将对应的语句分词，将其权重和分词结果一并存入数据，当用户搜索数据时候，再根据权重将结果排名，打分，再将返回结果呈现给用户。<br>`</p><p>如上所述，Elasticsearch具备以下特点：</p><ul><li>分布式实时文件存储，可将每一个字段存入索引，使其可以被检索到。</li><li>实时分析的分布式搜索引擎。<br>分布式：索引分拆成多个分片，每个分片可有零个或多个副本。集群中的每个数据节点都可承载一个或多个分片，并且协调和处理各种操作</li><li>可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。也可以运行在单台PC上</li><li>无需人工搭建集群（solr就需要人为配置，使用Zookeeper作为注册中心）负载再平衡和路由在大多数情况下自动完成。</li><li>Restful风格，一切API都遵循Rest原则，容易上手</li><li>近实时搜索，数据更新在Elasticsearch中几乎是完全同步的。</li><li>支持插件机制，分词插件、同步插件、Hadoop插件、可视化插件等。</li></ul><h3 id="1-1-3-版本"><a href="#1-1-3-版本" class="headerlink" title="1.1.3.版本"></a>1.1.3.版本</h3><p>目前Elasticsearch最新的版本有7.3了，这里测试使用的版本5.3.6，需要虚拟机JDK1.8及以上</p><h3 id="1-1-4-应用场景"><a href="#1-1-4-应用场景" class="headerlink" title="1.1.4.应用场景"></a>1.1.4.应用场景</h3><ul><li>新系统开发尝试使用ES作为存储和检索服务器<ul><li>场景一：使用Elasticsearch作为主要的后端</li><li>场景二：在现有系统中增加elasticsearch</li><li>场景三：使用elasticsearch和现有的工具</li><li><a href="https://blog.csdn.net/laoyang360/article/details/52227541" target="_blank" rel="noopener">引用</a></li></ul></li><li>现有系统升级需要支持全文检索服务，需要使用ES</li><li>典型<ul><li><strong>记录和日志分析</strong><ul><li>从Beats，Logstash到Ingest Nodes，Elasticsearch为您提供了大量的选项，可以在任何地方获取数据并将其索引化。然后，使用Kibana工具使您能够创建丰富的仪表板和分析，而Curator使得您自动化管理索引的生命周期。</li></ul></li><li><strong>采集和组合公共数据</strong><ul><li>与日志数据一样，Elastic Stack拥有大量工具，可以轻松抓取和索引远程数据。此外，与大多数文档存储一样，非严格的模式使Elasticsearch可以灵活地接收多个不同的数据源，并能使得这些数据可以管理和搜索。</li></ul></li><li><strong>事件数据和指标</strong><ul><li>Elasticsearch还可以很好地处理时间序列数据，如指标（metrics ）和应用程序事件。这是另一个巨大的Beats生态系统允许您轻松获取常见应用程序数据的区域。无论您使用何种技术，Elasticsearch都有很好的机会获取开箱即用的指标和事件…，添加该功能非常简单。</li></ul></li><li><strong>数据可视化</strong><ul><li>凭借大量的图表选项，地理数据的平铺服务和时间序列数据的TimeLion，Kibana是一款功能强大且易于使用的可视化工具。对于上面的每个用例，Kibana都会处理 一些可视化组件。一旦您对各种数据提取工具感到满意，您就会发现Elasticsearch + Kibana将成为您可视化数据的首选工具。</li></ul></li><li><strong>全文搜索</strong></li></ul></li></ul><h3 id="1-1-5-社区"><a href="#1-1-5-社区" class="headerlink" title="1.1.5.社区"></a>1.1.5.社区</h3><p>国外网站：<a href="https://discuss.elastic.co/" target="_blank" rel="noopener">https://discuss.elastic.co/</a></p><p>国内网站：<a href="https://elasticsearch.cn/" target="_blank" rel="noopener">https://elasticsearch.cn/</a></p><h2 id="1-2-安装和配置"><a href="#1-2-安装和配置" class="headerlink" title="1.2.安装和配置"></a>1.2.安装和配置</h2><p>为了模拟线上，在linux下安装Elasticsearch。</p><p>出于安全考虑，elasticsearch默认不允许以root账号运行。这里创建个一般管理员账号用来启动es</p><p>创建用户：<code>sh useradd wind</code></p><p>设置密码：<code>passwd xxxxxx</code></p><p>切换用户：<code>su - wind</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.3.6-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>上传解压缩：<code>tar -zxvf elasticsearch-5.3.6.tar.gz</code></p><p>方便管理可以把目录重命名：<code>mv elasticsearch-5.6.3 elasticsearch</code></p><h3 id="1-2-1-修改配置"><a href="#1-2-1-修改配置" class="headerlink" title="1.2.1.修改配置"></a>1.2.1.修改配置</h3><p>进入config目录：<code>cd config</code></p><p>需要修改的配置文件有两个：</p><p><img src="https://s2.ax1x.com/2019/08/05/e2CH8P.png" alt="e2CH8P.png"></p><ol><li><strong>jvm.options</strong></li></ol><p>Elasticsearch基于Lucene的，而Lucene底层是java实现，因此需要配置jvm参数。</p><p>编辑jvm.options：<code>vim jvm.options</code></p><p>默认配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms1g</span><br><span class="line">-Xmx1g</span><br></pre></td></tr></table></figure><p>调小一些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms512m</span><br><span class="line">-Xmx512m</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>elasticsearch.yml</strong></li></ol><ul><li>修改数据和日志目录：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">path.data:</span> <span class="string">/home/wind/elasticsearch/data</span> <span class="comment"># 数据目录位置</span></span><br><span class="line"><span class="string">path.logs:</span> <span class="string">/home/wind/elasticsearch/logs</span> <span class="comment"># 日志目录位置</span></span><br></pre></td></tr></table></figure><p>把data和logs目录修改指向了elasticsearch的安装目录。但是这两个目录并不存在，因此需要创建出来。</p><p>进入elasticsearch的根目录，然后创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir data</span><br><span class="line">mkdir logs</span><br></pre></td></tr></table></figure><ul><li>修改绑定的ip(必要)：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network.host: 0.0.0.0 # 绑定到0.0.0.0，允许任何ip来访问</span><br></pre></td></tr></table></figure><ul><li>开启跨域<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure></li></ul><p>默认只允许本机访问，修改为0.0.0.0后则可以远程访问</p><p>目前我们是做的单机安装，如果要做集群，只需要在这个配置文件中添加其它节点信息即可。</p><blockquote><p>elasticsearch.yml的其它可配置信息：</p></blockquote><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>cluster.name</td><td>配置elasticsearch的集群名称，默认是elasticsearch。建议修改成一个有意义的名称。</td></tr><tr><td>node.name</td><td>节点名，es会默认随机指定一个名字，建议指定一个有意义的名称，方便管理</td></tr><tr><td>path.conf</td><td>设置配置文件的存储路径，tar或zip包安装默认在es根目录下的config文件夹，rpm安装默认在/etc/ elasticsearch</td></tr><tr><td>path.data</td><td>设置索引数据的存储路径，默认是es根目录下的data文件夹，可以设置多个存储路径，用逗号隔开</td></tr><tr><td>path.logs</td><td>设置日志文件的存储路径，默认是es根目录下的logs文件夹</td></tr><tr><td>path.plugins</td><td>设置插件的存放路径，默认是es根目录下的plugins文件夹</td></tr><tr><td>bootstrap.memory_lock</td><td>设置为true可以锁住ES使用的内存，避免内存进行swap</td></tr><tr><td>network.host</td><td>设置bind_host和publish_host，设置为0.0.0.0允许外网访问</td></tr><tr><td>http.port</td><td>设置对外服务的http端口，默认为9200。</td></tr><tr><td>transport.tcp.port</td><td>集群结点之间通信端口</td></tr><tr><td>discovery.zen.ping.timeout</td><td>设置ES自动发现节点连接超时的时间，默认为3秒，如果网络延迟高可设置大些</td></tr><tr><td>discovery.zen.minimum_master_nodes</td><td>主结点数量的最少值 ,此值的公式为：(master_eligible_nodes / 2) + 1 ，比如：有3个符合要求的主结点，那么这里要设置为2</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="1-2-2-启动"><a href="#1-2-2-启动" class="headerlink" title="1.2.2.启动"></a>1.2.2.启动</h3><p>进入elasticsearch/bin目录输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./elasticsearch</span><br></pre></td></tr></table></figure><p>如发现报错了，启动失败，参考：</p><blockquote><p>链接：<a href="http://note.youdao.com/noteshare?id=137511c1db578b98e8ade622f927f444&sub=A05F7A7EA34F4C7EBCDEFE84DC953B2F" target="_blank" rel="noopener">解决启动报错问题</a></p></blockquote><blockquote><p>或者：<br>[1]. <a href="https://blog.51cto.com/6005355/2395591" target="_blank" rel="noopener">link1</a><br>[2].<a href="https://cloud.tencent.com/developer/article/1422171" target="_blank" rel="noopener">link2</a></p></blockquote><p>所有错误修改完毕，重启终端，否则配置无效。</p><p><code>./elasticsearch</code> 直接启动</p><p><code>./elasticsearch -d</code> 后台启动</p><p>判断是否启动成功，可执行如下命令，查看是否启用9200端口即可<br><code>ss -tanl</code><br>可以看到绑定了两个端口:</p><ul><li>9300：集群节点间通讯接口</li><li>9200：客户端访问接口</li></ul><p>在浏览器中访问：<a href="http://192.168.56.101:9200" target="_blank" rel="noopener">http://192.168.56.101:9200</a></p><h3 id="1-2-3-集群搭建-基于7-1-0"><a href="#1-2-3-集群搭建-基于7-1-0" class="headerlink" title="1.2.3 集群搭建(基于7.1.0)"></a>1.2.3 集群搭建(基于7.1.0)</h3><blockquote><p>环境</p></blockquote><p>CentOS 7 Elasticsearch 7.1.0 单机搭建，一主两从</p><blockquote><p>步骤</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 首先创建 elasticsearch-slave 文件夹</span><br><span class="line">mkdir /usr/java/elasticsearch-slave</span><br><span class="line"># 我本地的ES路径为 /usr/java//elasticsearch-7.1.0  ,使用下面的命令将其复制两份</span><br><span class="line">cp -r  /usr/java/elasticsearch-7.1.0 /usr/java/elasticsearch-slave/slave1</span><br><span class="line">cp -r  /usr/java/elasticsearch-7.1.0 /usr/java/elasticsearch-slave/slave2</span><br></pre></td></tr></table></figure><p>master节点配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 集群名称</span><br><span class="line">cluster.name: &quot;es_cluster&quot;</span><br><span class="line"> </span><br><span class="line"># 节点名称,这儿我直接取名为 master</span><br><span class="line">node.name: master</span><br><span class="line"># 是否可以成为master节点</span><br><span class="line">node.master: true</span><br><span class="line"># 是否允许该节点存储数据,默认开启</span><br><span class="line">node.data: true</span><br><span class="line"> </span><br><span class="line"># 网络绑定,这里我绑定 0.0.0.0,支持外网访问</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"> </span><br><span class="line"># 设置对外服务的http端口，默认为9200</span><br><span class="line">http.port: 9200</span><br><span class="line"> </span><br><span class="line"># 支持跨域访问</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"> </span><br><span class="line"># 设置节点间交互的tcp端口,默认是9300</span><br><span class="line">transport.tcp.port: 9300</span><br><span class="line"> </span><br><span class="line"># 手动指定可以成为 mater 的所有节点的 name 或者 ip，这些配置将会在第一次选举中进行计算</span><br><span class="line">cluster.initial_master_nodes: [&quot;127.0.0.1&quot;]</span><br></pre></td></tr></table></figure><p>Slave节点配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 集群名称，处于同一个集群所有节点，该名称必须相同</span><br><span class="line">cluster.name: &quot;es_cluster&quot;</span><br><span class="line"> </span><br><span class="line"># 节点名称,这儿我直接取名为 slave1</span><br><span class="line">node.name: slave1</span><br><span class="line"># 是否可以成为master节点</span><br><span class="line">node.master: false</span><br><span class="line"># 是否允许该节点存储数据,默认开启</span><br><span class="line">node.data: true</span><br><span class="line"> </span><br><span class="line"># 网络绑定,这里我绑定 0.0.0.0,支持外网访问</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"> </span><br><span class="line"># 设置对外服务的http端口，默认为9200，这里我们修改为 9201，不然会有端口冲突</span><br><span class="line">http.port: 9201</span><br><span class="line"> </span><br><span class="line"># 支持跨域访问</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"> </span><br><span class="line"># 集群发现</span><br><span class="line">discovery.seed_hosts: [&quot;127.0.0.1:9300&quot;]</span><br></pre></td></tr></table></figure><p>修改完后，启动 <code>slave1/bin/elasticsearch</code>即可。</p><p>slave2配置：</p><p>slave2配置和slave1的配置大多相同，只需要修改下面几个配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 节点名称,这儿我直接取名为 slave2</span><br><span class="line">node.name: slave2</span><br><span class="line"> </span><br><span class="line"># 设置对外服务的http端口，默认为9200，这里设置为 9202</span><br><span class="line">http.port: 9202</span><br></pre></td></tr></table></figure><p>这样，我们在本机就启动了一个ES集群，1个master节点，2个slave节点。</p><p>在ES 7.0.0中，官方文档明确指出，和 集群发现(Discovery)有关的配置主要由下面两个，下面一段节选、翻译自<a href="https://www.csdn.net/link?target_url=https%3A%2F%2Fwww.elastic.co%2Fguide%2Fen%2Felasticsearch%2Freference%2Fcurrent%2Fdiscovery-settings.html%23initial_master_nodes&id=89373246&token=e893b5f35ed639abcce92665380cea4c" target="_blank" rel="noopener">官方文档</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">discovery.seed_hosts</span><br><span class="line">开箱即用，再没有任何 Network 配置时，Elasticsearch将会自动获取可用的loopback addresses，并且会自动扫描 9300 - 9305 的本地端口尝试连接到运行在同一服务器上的其他节点。这提供了一种不需要不需要任何配置的集群体验。</span><br><span class="line"></span><br><span class="line">当您想要与其他主机上的节点组成群集时，你必须使用 discovery.seed_hosts 来提供群集中可以成为master ，可能存在并且可以连接到的其他节点的列表，以便为discovery process提供seed(使得 discovery process 能够发现节点)。此设置通常应包含群集中所有可以成为master节点的地址。需要注意的是，IPv6主机必须放在括号内。此设置的默认值为127.0.0.1，[::1]。</span><br><span class="line"></span><br><span class="line">cluster.initial_master_nodes</span><br><span class="line">当你第一次启动全新的Elasticsearch集群时，会有一个集群引导(cluster bootstrapping)步骤，这个步骤会确定一个 在第一次选举中 投票被计数的、并且可以成为 master节点的集合。在开发模式，如果没有配置 discovery settings，该步骤由节点自身自动执行。因为这种自动引导本质上是不安全的，当您在生产模式下启动一个全新的集群时，你必须显式指定那些可以成为master节点的名称或者IP地址，这些节点应该在第一次选举中计算选票数。</span><br></pre></td></tr></table></figure><p>启动时data目录下的文件可能会冲突，删掉报错的ES目录下的 data 目录，重新启动ES。</p><p><a href="https://blog.csdn.net/Zereao/article/details/89373246" target="_blank" rel="noopener">参考</a></p><h2 id="1-3-插件和工具"><a href="#1-3-插件和工具" class="headerlink" title="1.3.插件和工具"></a>1.3.插件和工具</h2><h3 id="1-3-1-Kibana"><a href="#1-3-1-Kibana" class="headerlink" title="1.3.1.Kibana"></a>1.3.1.Kibana</h3><p>Kibana是一个基于Node.js的Elasticsearch索引库数据统计工具，可以利用Elasticsearch的聚合功能，生成各种图表，如柱形图，线状图，饼图等。</p><p>而且还提供了操作Elasticsearch索引数据的控制台，并且提供了一定的API提示，非常有利于我们学习Elasticsearch的语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Kibana的汉化，从Kibana 6.8 和 ES 7.0开始支持。</span><br><span class="line">通过在 `kibana.yml`文件中，增加 i18n.locale: &quot;zh-CN&quot;，就支持中文显示了。</span><br></pre></td></tr></table></figure><h4 id="1-3-1-1-安装"><a href="#1-3-1-1-安装" class="headerlink" title="1.3.1.1.安装"></a>1.3.1.1.安装</h4><p>因为Kibana依赖于node，虚拟机没有安装node，而window中安装过。选择在window下使用kibana。</p><p>版本与elasticsearch保持一致，也是5.6.3</p><p><a href="https://www.elastic.co/cn/downloads/past-releases/kibana-5-6-3" target="_blank" rel="noopener">kibana下载地址</a></p><p>解压到特定目录即可</p><h4 id="1-3-1-2-配置运行"><a href="#1-3-1-2-配置运行" class="headerlink" title="1.3.1.2.配置运行"></a>1.3.1.2.配置运行</h4><p>进入安装目录下的config目录，修改kibana.yml文件：</p><p>修改elasticsearch服务器的地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch.url: &quot;http://192.168.91.128:5601&quot;</span><br></pre></td></tr></table></figure><p><code>kibana的服务如何在后台运行?</code> <code>|</code><br><code>nuhup bin/kibana 或者设置service启动</code></p><p>访问：<a href="http://127.0.0.1:5601" target="_blank" rel="noopener">http://127.0.0.1:5601</a></p><h4 id="1-3-1-3-控制台"><a href="#1-3-1-3-控制台" class="headerlink" title="1.3.1.3.控制台"></a>1.3.1.3.控制台</h4><p>选择左侧的DevTools菜单，即可进入控制台页面：</p><p>在页面右侧，就可以输入请求，访问Elasticsearch了。</p><h3 id="1-3-2-ik分词器"><a href="#1-3-2-ik分词器" class="headerlink" title="1.3.2.ik分词器"></a>1.3.2.ik分词器</h3><h4 id="1-3-2-1-安装"><a href="#1-3-2-1-安装" class="headerlink" title="1.3.2.1.安装"></a>1.3.2.1.安装</h4><p>上传zip包，解压到Elasticsearch目录的plugins目录中：</p><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" target="_blank" rel="noopener">ik分词器地址</a></p><p>使用unzip命令解压：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip elasticsearch-analysis-ik-5.6.3.zip -d ik-analyzer</span><br></pre></td></tr></table></figure><p>然后重启elasticsearch：</p><h4 id="1-3-2-2-测试"><a href="#1-3-2-2-测试" class="headerlink" title="1.3.2.2.测试"></a>1.3.2.2.测试</h4><p>在kibana控制台输入下面的请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;text&quot;:     &quot;这是一个简单的例子&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行得到结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;这是&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 0,</span><br><span class="line">      &quot;end_offset&quot;: 2,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;一个&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 2,</span><br><span class="line">      &quot;end_offset&quot;: 4,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;一&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 2,</span><br><span class="line">      &quot;end_offset&quot;: 3,</span><br><span class="line">      &quot;type&quot;: &quot;TYPE_CNUM&quot;,</span><br><span class="line">      &quot;position&quot;: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;个&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 3,</span><br><span class="line">      &quot;end_offset&quot;: 4,</span><br><span class="line">      &quot;type&quot;: &quot;COUNT&quot;,</span><br><span class="line">      &quot;position&quot;: 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;简单&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 4,</span><br><span class="line">      &quot;end_offset&quot;: 6,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 4</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;的&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 6,</span><br><span class="line">      &quot;end_offset&quot;: 7,</span><br><span class="line">      &quot;type&quot;: &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot;: 5</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;例子&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 7,</span><br><span class="line">      &quot;end_offset&quot;: 9,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 6</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-Head-插件"><a href="#1-3-3-Head-插件" class="headerlink" title="1.3.3.Head 插件"></a>1.3.3.Head 插件</h3><h4 id="1-3-3-1-概念"><a href="#1-3-3-1-概念" class="headerlink" title="1.3.3.1.概念"></a>1.3.3.1.概念</h4><p>elasticsearch-head是一个界面化的集群操作和管理工具，可以对集群进行傻瓜式操作。你可以通过插件把它集成到elasticsearch（5.0版本后不支持此方式）,也可以安装成一个独立webapp。elasticsearch-head插件是使用JavaScript开发的，依赖Node.js库，使用Grunt工具构建，所以等会我们要安装elasticsearch-head，还需要先安装Node.js和Grunt。</p><h4 id="1-3-3-2-应用"><a href="#1-3-3-2-应用" class="headerlink" title="1.3.3.2.应用"></a>1.3.3.2.应用</h4><p>elasticsearch-head主要的作用有以下这些方面：</p><ul><li>可以直接浏览数据</li><li>支持JSON验证器</li><li>支持重复请求计时器</li><li>支持使用javascript表达式变换结果</li><li>查看方便的查看集群状态，包括有多少个replication，多少个shared</li><li>查看索引的状态,显示集群的状态</li><li>提供便捷的查询方式，通过选择的方式查询</li><li>搜索接口能够查询集群中原始json或表格格式的检索数据</li><li>请求方法(get、put、post、delete),查询json数据,节点和路径</li></ul><hr><ul><li>绿色，最健康的状态，代表所有的分片包括备份都可用</li><li>黄色，基本的分片可用，但是备份不可用（也可能是没有备份），下文有提到</li><li>红色，部分的分片可用，表明分片有一部分损坏。此时执行查询部分数据仍然可以查到，遇到这种情况，还是赶快解决比较好</li><li>灰色，未连接到elasticsearch服务<h4 id="1-3-3-3-注意事项"><a href="#1-3-3-3-注意事项" class="headerlink" title="1.3.3.3.注意事项"></a>1.3.3.3.注意事项</h4>前端是用<code>nodejs</code>编写。<br>因为是前端技术直接访问es库，所以es必须开放对外接口，而es head又有比较高的权限，可以删除任何节点，且不带安全验证，授权，因此在实际生产环境要慎用。</li></ul><h4 id="1-3-3-4-友链"><a href="#1-3-3-4-友链" class="headerlink" title="1.3.3.4.友链"></a>1.3.3.4.友链</h4><p>文档入口：<a href="http://note.youdao.com/noteshare?id=91aaf2ff3ac6030e4a7890959df55fc0&sub=E8CD2E3E12664B54A4447661A37C9FCA" target="_blank" rel="noopener">link</a></p><h3 id="1-3-4-esrally（压测）"><a href="#1-3-4-esrally（压测）" class="headerlink" title="1.3.4.esrally（压测）"></a>1.3.4.esrally（压测）</h3><p>性能工具esrally主要功能如下：</p><ul><li>自动创建、压测和销毁 es 集群</li><li>可分 es 版本管理压测数据和方案</li><li>完善的压测数据展示，支持不同压测之间的数据对比分析，也可以将数据存储到指定的es中进行二次分析</li><li>支持收集 JVM 详细信息，比如内存、GC等数据来定位性能问题</li></ul><p><a href="https://github.com/elastic/rally" target="_blank" rel="noopener">源码地址</a></p><blockquote><p>参考：[1]<a href="http://blog.csdn.net/laoyang360/article/details/52155481" target="_blank" rel="noopener">link1</a><br>[2]<a href="https://elasticsearch.cn/article/275" target="_blank" rel="noopener">link2</a></p></blockquote><h3 id="1-3-5-x-pack性能监控-待"><a href="#1-3-5-x-pack性能监控-待" class="headerlink" title="1.3.5.x-pack性能监控(待)"></a>1.3.5.x-pack性能监控(待)</h3><p>获取进程运行时资源与状态信息并存储至es中。可通过kibana查看es、logstash性能指标，试用版包括集群状态、延迟、索引速率、检索速率、内存、cpu、io、磁盘、文件量等还可以看到集群数据负载均衡时的情况。商用版还支持安全、告警等功能</p><h3 id="1-3-6-es-sql-待"><a href="#1-3-6-es-sql-待" class="headerlink" title="1.3.6.es-sql(待)"></a>1.3.6.es-sql(待)</h3><p>用sql查询elasticsearch的工具，将封装复杂的dsl语句封装成sql</p><h3 id="1-3-7-Logstash-安装与导入数据-待"><a href="#1-3-7-Logstash-安装与导入数据-待" class="headerlink" title="1.3.7.Logstash 安装与导入数据(待)"></a>1.3.7.Logstash 安装与导入数据(待)</h3><p>数据处理管。采样各种样式、大小的数据来源，实时解析和转换数据，选择众多输出目标导出数据</p><h3 id="1-3-8-beats-待"><a href="#1-3-8-beats-待" class="headerlink" title="1.3.8.beats(待)"></a>1.3.8.beats(待)</h3><p>轻量级的数据采集工具，可监控网络流量、日志数据、进程信息（负载、内存、磁盘等），支持docker镜像的file采集</p><h3 id="1-3-9-在-Docker-容器中运行-Elasticsearch，Kibana-和-Cerebro-待"><a href="#1-3-9-在-Docker-容器中运行-Elasticsearch，Kibana-和-Cerebro-待" class="headerlink" title="1.3.9.在 Docker 容器中运行 Elasticsearch，Kibana 和 Cerebro(待)"></a>1.3.9.在 Docker 容器中运行 Elasticsearch，Kibana 和 Cerebro(待)</h3><p>搭建Cerebro Elasticsearch</p><p>文档入口：<a href="http://note.youdao.com/noteshare?id=16ebdf74e9b19ba14a5a6de9ce6a4d98&sub=A0CCF05E1F96444DB253485310F2B21A" target="_blank" rel="noopener">link</a></p><h1 id="2-操作索引"><a href="#2-操作索引" class="headerlink" title="2.操作索引"></a>2.操作索引</h1><h2 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1.基本概念"></a>2.1.基本概念</h2><p>1）<code>Cluster</code>：集群。<br>ES可以作为一个独立的单个搜索服务器。不过，为了处理大型数据集，实现容错和高可用性，ES可以运行在许多互相合作的服务器上。这些服务器的集合称为集群。</p><p>2）<code>Node</code>：节点。<br>形成集群的每个服务器称为节点。</p><p>3）<code>Shard</code>：分片。<br>当有大量的文档时，由于内存的限制、磁盘处理能力不足、无法足够快的响应客户端的请求等，一个节点可能不够。这种情况下，数据可以分为较小的分片。每个分片放到不同的服务器上。<br>当你查询的索引分布在多个分片上时，ES会把查询发送给每个相关的分片，并将结果组合在一起，而应用程序并不知道分片的存在。即：这个过程对用户来说是透明的。</p><p>4）<code>Replia</code>：副本。<br>为提高查询吞吐量或实现高可用性，可以使用分片副本。<br>副本是一个分片的精确复制，每个分片可以有零个或多个副本。ES中可以有许多相同的分片，其中之一被选择更改索引操作，这种特殊的分片称为主分片。<br>当主分片丢失时，如：该分片所在的数据不可用时，集群将副本提升为新的主分片。</p><p>5）<code>全文检索</code>:<br>全文检索就是对一篇文章进行索引，可以根据关键字搜索，类似于mysql里的like语句。<br>全文索引就是把内容根据词的意义进行分词，然后分别创建索引，例如”你们的激情是因为什么事情来的” 可能会被分词成：“你们“，”激情“，“什么事情“，”来“ 等token，这样当你搜索“你们” 或者 “激情” 都会把这句搜出来。</p><p>Elasticsearch也是基于Lucene的全文检索库，本质也是存储数据，很多概念与MySQL类似的。</p><pre><code>- GET：获取请求对象的当前状态。 - POST：改变对象的当前状态。 - PUT：创建一个对象。 - DELETE：销毁对象。 - HEAD：请求获取对象的基础信息。</code></pre><hr><p><strong>对比mysql关系图例</strong>：</p><p><img src="https://s2.ax1x.com/2019/08/05/e2AeOK.png" alt="e2AeOK.png"></p><ul><li>关系型数据库中的数据库（<code>DataBase</code>），等价于ES中的索引（<code>Index</code>）</li><li>一个数据库下面有N张表（<code>Table</code>），等价于1个索引Index下面有N多类型（<code>Type</code>），</li><li>一个数据库表（Table）下的数据由多行（ROW）多列（<code>column</code>，属性）组成，等价于1个Type由多个文档（<code>Document</code>）和多Field组成。</li><li>在一个关系型数据库里面，schema定义了表、每个表的字段，还有表和字段之间的关系。 与之对应的，在ES中：Mapping定义索引下的Type的字段处理规则，即索引如何建立、索引类型、是否保存原始索引JSON文档、是否压缩原始JSON文档、是否需要分词处理、如何进行分词处理等。</li><li>在数据库中的增insert、删delete、改update、查search操作等价于ES中的增PUT/POST、删Delete、改_update、查GET.</li></ul><hr><p><strong>详细说明</strong>：</p><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>索引库（indices)</td><td>indices是index的复数，代表许多的索引</td></tr><tr><td>类型（type）</td><td>类型是模拟mysql中的table概念，一个索引库下可以有不同类型的索引，比如商品索引，订单索引，其数据格式不同。不过这会导致索引库混乱，因此未来版本中会移除这个概念</td></tr><tr><td>文档（document）</td><td>存入索引库原始的数据。比如每一条商品信息，就是一个文档</td></tr><tr><td>字段（field）</td><td>文档中的属性</td></tr><tr><td>映射配置（mappings）</td><td>字段的数据类型、属性、是否索引、是否存储等特性</td></tr></tbody></table><p>与Lucene和solr中的概念类似。</p><p>另，在SolrCloud中，有一些集群相关的概念，在Elasticsearch也有类似的：</p><ul><li>索引集（Indices，index的复数）：逻辑上的完整索引</li><li>分片（shard）：数据拆分后的各个部分</li><li>副本（replica）：每个分片的复制</li></ul><p>要注意的是：Elasticsearch本身就是分布式的，因此即便你只有一个节点，Elasticsearch默认也会对你的数据进行分片和副本操作，当你向集群添加新数据时，数据也会在新加入的节点中进行平衡。</p><h2 id="2-2-创建索引"><a href="#2-2-创建索引" class="headerlink" title="2.2.创建索引"></a>2.2.创建索引</h2><h3 id="2-2-1-语法"><a href="#2-2-1-语法" class="headerlink" title="2.2.1.语法"></a>2.2.1.语法</h3><p>Elasticsearch采用Rest风格API，因此其API就是一次http请求，你可以用任何工具发起http请求</p><p>创建索引的请求格式：</p><ul><li><p>请求方式：PUT</p></li><li><p>请求路径：/索引库名</p></li><li><p>请求参数：json格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"number_of_shards"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"number_of_replicas"</span>: <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>settings：索引库的设置</p><ul><li>number_of_shards：分片数量</li><li>number_of_replicas：副本数量</li></ul></li></ul><h3 id="2-2-2-使用kibana创建"><a href="#2-2-2-使用kibana创建" class="headerlink" title="2.2.2.使用kibana创建"></a>2.2.2.使用kibana创建</h3><p>kibana的控制台，可以对http请求进行简化，示例：</p><p><img src="https://i.loli.net/2019/08/05/peKs1cMAUFQumC5.png" alt="QQ图片20190805152058.png"></p><p>相当于是省去了elasticsearch的服务器地址</p><h2 id="2-3-查看索引设置"><a href="#2-3-查看索引设置" class="headerlink" title="2.3.查看索引设置"></a>2.3.查看索引设置</h2><p>Get请求可以帮我们查看索引信息</p><blockquote><p>语法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></table></figure><p>或者，使用<code>GET *</code>来查询所有索引库配置：</p><h2 id="2-4-删除索引"><a href="#2-4-删除索引" class="headerlink" title="2.4.删除索引"></a>2.4.删除索引</h2><p>删除索引使用DELETE请求</p><blockquote><p>语法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /索引库名</span><br></pre></td></tr></table></figure><p>用HEAD请求，查看索引是否存在：</p><h2 id="2-5-映射配置"><a href="#2-5-映射配置" class="headerlink" title="2.5.映射配置"></a>2.5.映射配置</h2><p>索引有了，接下来肯定是添加数据。但是，在添加数据之前必须定义映射。</p><p><code>映射是定义文档的过程，文档包含哪些字段，这些字段是否保存，是否索引，是否分词等</code><br>只有配置清楚，Elasticsearch才会帮我们进行索引库的创建（不一定）</p><h3 id="2-5-1-创建映射字段"><a href="#2-5-1-创建映射字段" class="headerlink" title="2.5.1.创建映射字段"></a>2.5.1.创建映射字段</h3><blockquote><p>语法</p></blockquote><p>请求方式依然是PUT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名/_mapping/类型名称</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;: &#123;</span><br><span class="line">    &quot;字段名&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;类型&quot;,</span><br><span class="line">      &quot;index&quot;: true，</span><br><span class="line">      &quot;store&quot;: true，</span><br><span class="line">      &quot;analyzer&quot;: &quot;分词器&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类型名称：就是前面将的type的概念，类似于数据库中的不同表<br>字段名：任意填写 ，可以指定许多属性，例如：</li><li>type：类型，可以是text、long、short、date、integer、object等</li><li>index：是否索引，默认为true</li><li>store：是否存储，默认为false</li><li>analyzer：分词器，这里的<code>ik_max_word</code>即使用ik分词器</li></ul><blockquote><p>示例</p></blockquote><p>发起请求：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT wind/_mapping/books</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"title"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">      <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"images"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"keyword"</span>,</span><br><span class="line">      <span class="attr">"index"</span>: <span class="string">"false"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"price"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"float"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;acknowledged&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-2-查看映射关系"><a href="#2-5-2-查看映射关系" class="headerlink" title="2.5.2.查看映射关系"></a>2.5.2.查看映射关系</h3><blockquote><p>语法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名/_mapping</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_mapping</span><br></pre></td></tr></table></figure><blockquote><p>响应：</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"wind"</span>: &#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">      <span class="attr">"books"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">          <span class="attr">"images"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"keyword"</span>,</span><br><span class="line">            <span class="attr">"index"</span>: <span class="literal">false</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"price"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"float"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"title"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">            <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-3-字段属性详解"><a href="#2-5-3-字段属性详解" class="headerlink" title="2.5.3.字段属性详解"></a>2.5.3.字段属性详解</h3><h4 id="2-5-3-1-type"><a href="#2-5-3-1-type" class="headerlink" title="2.5.3.1.type"></a>2.5.3.1.type</h4><p>Elasticsearch中支持的数据类型非常丰富：</p><p>这里提几个关键的：</p><ul><li><p>String类型，又分两种：</p><ul><li>text：可分词，不可参与聚合</li><li>keyword：不可分词，数据会作为完整字段进行匹配，可以参与聚合</li></ul></li><li><p>Numerical：数值类型，分两类</p><ul><li>基本数据类型：long、interger、short、byte、double、float、half_float</li><li>浮点数的高精度类型：scaled_float<ul><li>需要指定一个精度因子，比如10或100。elasticsearch会把真实值乘以这个因子后存储，取出时再还原。</li></ul></li></ul></li><li><p>Date：日期类型</p><p>elasticsearch可以对日期格式化为字符串存储，但是建议我们存储为毫秒值，存储为long，节省空间。</p></li></ul><h4 id="2-5-3-2-index"><a href="#2-5-3-2-index" class="headerlink" title="2.5.3.2.index"></a>2.5.3.2.index</h4><p>index影响字段的索引情况。</p><ul><li>true：字段会被索引，则可以用来进行搜索。默认值就是true</li><li>false：字段不会被索引，不能用来搜索</li></ul><p>index的默认值就是true，也就是说你不进行任何配置，所有字段都会被索引。</p><p>但是有些字段是我们不希望被索引的，比如商品的图片信息，就需要手动设置index为false。</p><h4 id="2-5-3-3-store"><a href="#2-5-3-3-store" class="headerlink" title="2.5.3.3.store"></a>2.5.3.3.store</h4><p>是否将数据进行额外存储。</p><p>在学习lucene和solr时，我们知道如果一个字段的store设置为false，那么在文档列表中就不会有这个字段的值，用户的搜索结果中不会显示出来。</p><p>但是在Elasticsearch中，即便store设置为false，也可以搜索到结果。</p><p>原因是Elasticsearch在创建文档索引时，会将文档中的原始数据备份，保存到一个叫做<code>_source</code>的属性中。而且我们可以通过过滤<code>_source</code>来选择哪些要显示，哪些不显示。</p><p>而如果设置store为true，就会在<code>_source</code>以外额外存储一份数据，多余，因此一般我们都会将store设置为false，事实上，<strong>store的默认值就是false。</strong></p><h4 id="2-5-3-4-boost"><a href="#2-5-3-4-boost" class="headerlink" title="2.5.3.4.boost"></a>2.5.3.4.boost</h4><p>激励因子，这个与lucene中一样，用的不多，可参考官方文档：</p><h2 id="2-6-新增数据"><a href="#2-6-新增数据" class="headerlink" title="2.6.新增数据"></a>2.6.新增数据</h2><h3 id="2-6-1-随机生成id"><a href="#2-6-1-随机生成id" class="headerlink" title="2.6.1.随机生成id"></a>2.6.1.随机生成id</h3><p>通过POST请求，可以向一个已经存在的索引库中添加数据。</p><blockquote><p>语法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /索引库名/类型名</span><br><span class="line">&#123;</span><br><span class="line">    &quot;key&quot;:&quot;value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /wind/books/</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"title"</span>:<span class="string">"时间管理"</span>,</span><br><span class="line">    <span class="attr">"images"</span>:<span class="string">"http://image.xxx.com/12345.jpg"</span>,</span><br><span class="line">    <span class="attr">"price"</span>:<span class="number">99.00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"wind"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"books"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"AWxkohRi4Sn5GW_x380G"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"result"</span>: <span class="string">"created"</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过kibana查看数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> _search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>:&#123;</span><br><span class="line">        <span class="string">"match_all"</span>:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_index"</span>: <span class="string">"wind"</span>,</span><br><span class="line">    <span class="attr">"_type"</span>: <span class="string">"books"</span>,</span><br><span class="line">    <span class="attr">"_id"</span>: <span class="string">"AWxkohRi4Sn5GW_x380G"</span>,</span><br><span class="line">    <span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"_source"</span>: &#123;</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"时间管理"</span>,</span><br><span class="line">      <span class="attr">"images"</span>: <span class="string">"http://image.xxx.com/12345.jpg"</span>,</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">99</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><code>_source</code>：源文档信息，所有的数据都在里面。</li><li><code>_id</code>：这条文档的唯一标示，与文档自己的id字段没有关联</li></ul><h3 id="2-6-2-自定义id"><a href="#2-6-2-自定义id" class="headerlink" title="2.6.2.自定义id"></a>2.6.2.自定义id</h3><p>如果想要自己新增的时候指定id，可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /索引库名/类型/id值</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /wind/books/2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"title"</span>:<span class="string">"时间简史"</span>,</span><br><span class="line">    <span class="attr">"images"</span>:<span class="string">"http://image.xxx.com/13453.jpg"</span>,</span><br><span class="line">    <span class="attr">"price"</span>:<span class="number">66.00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"wind"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"books"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"2"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"时间简史"</span>,</span><br><span class="line">    <span class="attr">"images"</span>: <span class="string">"http://image.xxx.com/13453.jpg"</span>,</span><br><span class="line">    <span class="attr">"price"</span>: <span class="number">66</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-3-智能判断"><a href="#2-6-3-智能判断" class="headerlink" title="2.6.3.智能判断"></a>2.6.3.智能判断</h3><p>在学习Solr在新增数据时，只能使用提前配置好映射属性的字段，否则就会报错。</p><p>不过在Elasticsearch中并没有这样的规定。</p><p>事实上Elasticsearch非常智能，你不需要给索引库设置任何mapping映射，它也可以根据你输入的数据来判断类型，动态添加数据映射。</p><p>测试一下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /wind/books/3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"title"</span>:<span class="string">"其他书籍"</span>,</span><br><span class="line">    <span class="attr">"images"</span>:<span class="string">"http://image.xxx.com/39871.jpg"</span>,</span><br><span class="line">    <span class="attr">"price"</span>:<span class="number">66.00</span>,</span><br><span class="line">    <span class="attr">"stock"</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">"saleable"</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里额外添加了stock库存，和saleable是否上架两个字段。</p><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"wind"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"books"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"3"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"其他书籍"</span>,</span><br><span class="line">    <span class="attr">"images"</span>: <span class="string">"http://image.xxx.com/39871.jpg"</span>,</span><br><span class="line">    <span class="attr">"price"</span>: <span class="number">66</span>,</span><br><span class="line">    <span class="attr">"stock"</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">"saleable"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看下索引库的映射关系<code>GET _mapping</code>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"wind "</span>: &#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">      <span class="attr">"books"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">          <span class="attr">"images"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"keyword"</span>,</span><br><span class="line">            <span class="attr">"index"</span>: <span class="literal">false</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"price"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"float"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"saleable"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"boolean"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"stock"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"title"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">            <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stock和saleable都被成功映射了。</p><h2 id="2-7-修改数据"><a href="#2-7-修改数据" class="headerlink" title="2.7.修改数据"></a>2.7.修改数据</h2><p>把刚才新增的请求方式改为PUT，就是修改了。不过修改必须指定id，</p><ul><li>id对应文档存在，则修改</li><li>id对应文档不存在，则新增</li></ul><p>比如，我们把id为3的数据进行修改：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /wind/books/3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"title"</span>:<span class="string">"其他类型书籍"</span>,</span><br><span class="line">    <span class="attr">"images"</span>:<span class="string">"http://image.xxx.com/23241.jpg"</span>,</span><br><span class="line">    <span class="attr">"price"</span>:<span class="number">66.00</span>,</span><br><span class="line">    <span class="attr">"stock"</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="attr">"saleable"</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"wind"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"books"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"3"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"其他类型书籍"</span>,</span><br><span class="line">    <span class="attr">"images"</span>: <span class="string">"http://image.xxx.com/23241.jpg"</span>,</span><br><span class="line">    <span class="attr">"price"</span>: <span class="number">66</span>,</span><br><span class="line">    <span class="attr">"stock"</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="attr">"saleable"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-8-删除数据"><a href="#2-8-删除数据" class="headerlink" title="2.8.删除数据"></a>2.8.删除数据</h2><p>删除使用DELETE请求，同样，需要根据id进行删除：</p><blockquote><p>语法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /索引库名/类型名/id值</span><br></pre></td></tr></table></figure><h1 id="3-查询"><a href="#3-查询" class="headerlink" title="3.查询"></a>3.查询</h1><p>我们从4块来讲查询：</p><ul><li>基本查询</li><li><code>_source</code>过滤</li><li>结果过滤</li><li>高级查询</li><li>排序</li></ul><h2 id="3-1-基本查询："><a href="#3-1-基本查询：" class="headerlink" title="3.1.基本查询："></a>3.1.基本查询：</h2><blockquote><p>基本语法</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"查询类型"</span>:&#123;</span><br><span class="line">            <span class="attr">"查询条件"</span>:<span class="string">"查询条件值"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的query代表一个查询对象，里面可以有不同的查询属性</p><ul><li>查询类型：<ul><li>例如：<code>match_all</code>， <code>match</code>，<code>term</code> ， <code>range</code> 等等</li></ul></li><li>查询条件：查询条件会根据类型的不同，写法也有差异，后面详细讲解</li></ul><h3 id="3-1-1-查询所有（match-all"><a href="#3-1-1-查询所有（match-all" class="headerlink" title="3.1.1 查询所有（match_all)"></a>3.1.1 查询所有（match_all)</h3><blockquote><p>示例：</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>query</code>：代表查询对象</li><li><code>match_all</code>：代表查询所有</li><li>took：查询花费时间，单位是毫秒</li><li>time_out：是否超时</li><li>_shards：分片信息</li><li>hits：搜索结果总览对象<ul><li>total：搜索到的总条数</li><li>max_score：所有结果中文档得分的最高分</li><li>hits：搜索结果的文档对象数组，每个元素是一条搜索到的文档信息<ul><li>_index：索引库</li><li>_type：文档类型</li><li>_id：文档id</li><li>_score：文档得分</li><li>_source：文档的源数据</li></ul></li></ul></li></ul><h3 id="3-1-2-匹配查询（match）"><a href="#3-1-2-匹配查询（match）" class="headerlink" title="3.1.2 匹配查询（match）"></a>3.1.2 匹配查询（match）</h3><p>我们先加入一条数据，便于测试：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /wind/books/3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"title"</span>:<span class="string">"经济管理"</span>,</span><br><span class="line">    <span class="attr">"images"</span>:<span class="string">"http://image.xxx.com/2249122.jpg"</span>,</span><br><span class="line">    <span class="attr">"price"</span>:<span class="number">89.00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>or关系</li></ul><p><code>match</code>类型查询，会把查询条件进行分词，然后进行查询,多个词条之间是or的关系</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match"</span>:&#123;</span><br><span class="line">            <span class="attr">"title"</span>:<span class="string">"经济管理"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">4.120749</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"wind"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"books"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">4.120749</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"title"</span>: <span class="string">"经济管理"</span>,</span><br><span class="line">          <span class="attr">"images"</span>: <span class="string">"http://image.xxx.com/2249122.jpg"</span>,</span><br><span class="line">          <span class="attr">"price"</span>: <span class="number">89</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"wind"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"books"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"AWxkrFq84Sn5GW_x380S"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">0.5051683</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"title"</span>: <span class="string">"时间管理"</span>,</span><br><span class="line">          <span class="attr">"images"</span>: <span class="string">"http://image.xxx.com/12345.jpg"</span>,</span><br><span class="line">          <span class="attr">"price"</span>: <span class="number">99</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的案例中，不仅会查询“经济管理”，而且与管理相关的都会查询到，多个词之间是<code>or</code>的关系。</p><ul><li>and关系</li></ul><p>某些情况下，我们需要更精确查找，我们希望这个关系变成<code>and</code>，可以这样做：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"title"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"经济管理"</span>,</span><br><span class="line">            <span class="attr">"operator"</span>: <span class="string">"and"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">24</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">4.120749</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"wind"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"books"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">4.120749</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"title"</span>: <span class="string">"经济管理"</span>,</span><br><span class="line">          <span class="attr">"images"</span>: <span class="string">"http://image.xxx.com/2249122.jpg"</span>,</span><br><span class="line">          <span class="attr">"price"</span>: <span class="number">89</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例中，只有同时包含<code>经济</code>和<code>管理</code>的词条才会被搜索到。</p><ul><li>or和and之间？</li></ul><p>在 <code>or</code> 与 <code>and</code> 间二选一有点过于非黑即白。 如果用户给定的条件分词后有 5 个查询词项，想查找只包含其中 4 个词的文档，该如何处理？将 operator 操作符参数设置成 <code>and</code> 只会将此文档排除。</p><p>有时候这正是我们期望的，但在全文搜索的大多数应用场景下，我们既想包含那些可能相关的文档，同时又排除那些不太相关的。换句话说，我们想要处于中间某种结果。</p><p><code>match</code> 查询支持 <code>minimum_should_match</code> 最小匹配参数， 这让我们可以指定必须匹配的词项数用来表示一个文档是否相关。我们可以将其设置为某个具体数字，更常用的做法是将其设置为一个<code>百分数</code>，因为我们无法控制用户搜索时输入的单词数量：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match"</span>:&#123;</span><br><span class="line">            <span class="attr">"title"</span>:&#123;</span><br><span class="line">            <span class="attr">"query"</span>:<span class="string">"经济模式管理"</span>,</span><br><span class="line">            <span class="attr">"minimum_should_match"</span>: <span class="string">"75%"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例中，搜索语句可以分为3个词，如果使用and关系，需要同时满足3个词才会被搜索到。这里我们采用最小品牌数：75%，那么也就是说只要匹配到总词条数量的75%即可，这里3*75% 约等于2。所以只要包含2个词条就算满足条件了。</p><h3 id="3-1-3-多字段查询（multi-match）"><a href="#3-1-3-多字段查询（multi-match）" class="headerlink" title="3.1.3 多字段查询（multi_match）"></a>3.1.3 多字段查询（multi_match）</h3><p><code>multi_match</code>与<code>match</code>类似，不同的是它可以在多个字段中查询</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>:    <span class="string">"管理"</span>,</span><br><span class="line">            <span class="attr">"fields"</span>:   [ <span class="string">"title"</span>, <span class="string">"subTitle"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例中，在title字段和subtitle字段中查询<code>管理</code>这个词</p><h3 id="3-1-4-词条匹配-term"><a href="#3-1-4-词条匹配-term" class="headerlink" title="3.1.4 词条匹配(term)"></a>3.1.4 词条匹配(term)</h3><p><code>term</code> 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些<strong>未分词</strong>的字符串</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"term"</span>:&#123;</span><br><span class="line">            <span class="attr">"price"</span>:<span class="number">99.00</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-5-多词条精确匹配-terms"><a href="#3-1-5-多词条精确匹配-terms" class="headerlink" title="3.1.5 多词条精确匹配(terms)"></a>3.1.5 多词条精确匹配(terms)</h3><p><code>terms</code> 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"terms"</span>:&#123;</span><br><span class="line">            <span class="attr">"price"</span>:[<span class="number">66.00</span>,<span class="number">89.00</span>,<span class="number">99.00</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-结果过滤"><a href="#3-2-结果过滤" class="headerlink" title="3.2.结果过滤"></a>3.2.结果过滤</h2><p>默认情况下，elasticsearch在搜索的结果中，会把文档中保存在<code>_source</code>的所有字段都返回。</p><p>如果我们只想获取其中的部分字段，我们可以添加<code>_source</code>的过滤</p><h3 id="3-2-1-直接指定字段"><a href="#3-2-1-直接指定字段" class="headerlink" title="3.2.1.直接指定字段"></a>3.2.1.直接指定字段</h3><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_source"</span>: [<span class="string">"title"</span>,<span class="string">"price"</span>],</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"term"</span>: &#123;</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">99</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-指定includes和excludes"><a href="#3-2-2-指定includes和excludes" class="headerlink" title="3.2.2.指定includes和excludes"></a>3.2.2.指定includes和excludes</h3><p>我们也可以通过：</p><ul><li>includes：来指定想要显示的字段</li><li>excludes：来指定不想要显示的字段</li></ul><p>二者都是可选的。</p><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"includes"</span>:[<span class="string">"title"</span>,<span class="string">"price"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"term"</span>: &#123;</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">89</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与下面的结果将是一样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">     <span class="attr">"excludes"</span>: [<span class="string">"images"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"term"</span>: &#123;</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">89</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-高级查询"><a href="#3-3-高级查询" class="headerlink" title="3.3 高级查询"></a>3.3 高级查询</h2><h3 id="3-3-1-布尔组合（bool"><a href="#3-3-1-布尔组合（bool" class="headerlink" title="3.3.1 布尔组合（bool)"></a>3.3.1 布尔组合（bool)</h3><p><code>bool</code>把各种其它查询通过<code>must</code>（与）、<code>must_not</code>（非）、<code>should</code>（或）的方式进行组合</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"管理"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>:  <span class="string">"经济"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>:   &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"时间"</span> &#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-范围查询-range"><a href="#3-3-2-范围查询-range" class="headerlink" title="3.3.2 范围查询(range)"></a>3.3.2 范围查询(range)</h3><p><code>range</code> 查询找出那些落在指定区间内的数字或者时间</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"range"</span>: &#123;</span><br><span class="line">            <span class="attr">"price"</span>: &#123;</span><br><span class="line">                <span class="attr">"gte"</span>:  <span class="number">10.0</span>,</span><br><span class="line">                <span class="attr">"lt"</span>:   <span class="number">100.00</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range</code>查询允许以下字符：</p><table><thead><tr><th align="center">操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">gt</td><td align="center">大于</td></tr><tr><td align="center">gte</td><td align="center">大于等于</td></tr><tr><td align="center">lt</td><td align="center">小于</td></tr><tr><td align="center">lte</td><td align="center">小于等于</td></tr></tbody></table><h3 id="3-3-3-模糊查询-fuzzy"><a href="#3-3-3-模糊查询-fuzzy" class="headerlink" title="3.3.3 模糊查询(fuzzy)"></a>3.3.3 模糊查询(fuzzy)</h3><p>我们新增一个商品：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /wind/books/4</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"title"</span>:<span class="string">"cherish时间"</span>,</span><br><span class="line">    <span class="attr">"images"</span>:<span class="string">"http://image.xxx.com/213131.jpg"</span>,</span><br><span class="line">    <span class="attr">"price"</span>:<span class="number">79.00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fuzzy</code> 查询是 <code>term</code> 查询的模糊等价。它允许用户搜索词条与实际词条的拼写出现偏差，但是偏差的编辑距离不得超过2：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"cherism"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的查询，也能查询到</p><p>我们可以通过<code>fuzziness</code>来指定允许的编辑距离：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">        <span class="attr">"title"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>:<span class="string">"cherism"</span>,</span><br><span class="line">            <span class="attr">"fuzziness"</span>:<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-过滤-filter"><a href="#3-4-过滤-filter" class="headerlink" title="3.4 过滤(filter)"></a>3.4 过滤(filter)</h2><blockquote><p><strong>条件查询中进行过滤</strong></p></blockquote><p>所有的查询都会影响到文档的评分及排名。如果我们需要在查询结果中进行过滤，并且不希望过滤条件影响评分，那么就不要把过滤条件作为查询条件来用。而是使用<code>filter</code>方式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">        <span class="attr">"must"</span>:&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"时间管理"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"filter"</span>:&#123;</span><br><span class="line">                <span class="attr">"range"</span>:&#123;<span class="attr">"price"</span>:&#123;<span class="attr">"gt"</span>:<span class="number">20.00</span>,<span class="attr">"lt"</span>:<span class="number">200.00</span>&#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>filter</code>中还可以再次进行<code>bool</code>组合条件过滤。</p><blockquote><p><strong>无查询条件，直接过滤</strong></p></blockquote><p>如果一次查询只有过滤，没有查询条件，不希望进行评分，我们可以使用<code>constant_score</code>取代只有 filter 语句的 bool 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"constant_score"</span>:   &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">             <span class="attr">"range"</span>:&#123;<span class="attr">"price"</span>:&#123;<span class="attr">"gt"</span>:<span class="number">20.00</span>,<span class="attr">"lt"</span>:<span class="number">200.00</span>&#125;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-排序"><a href="#3-5-排序" class="headerlink" title="3.5 排序"></a>3.5 排序</h2><h3 id="3-5-1-单字段排序"><a href="#3-5-1-单字段排序" class="headerlink" title="3.5.1 单字段排序"></a>3.5.1 单字段排序</h3><p><code>sort</code> 可以让我们按照不同的字段进行排序，并且通过<code>order</code>指定排序的方式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /wind/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"时间管理"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"price"</span>: &#123;</span><br><span class="line">        <span class="attr">"order"</span>: <span class="string">"asc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-2-多字段排序"><a href="#3-5-2-多字段排序" class="headerlink" title="3.5.2 多字段排序"></a>3.5.2 多字段排序</h3><p>假定我们想要结合使用 price和 _score（得分） 进行查询，并且匹配的结果首先按照价格排序，然后按照相关性得分排序：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET wind/books/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">        <span class="attr">"must"</span>:&#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"时间管理"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"filter"</span>:&#123;</span><br><span class="line">                <span class="attr">"range"</span>:&#123;<span class="attr">"price"</span>:&#123;<span class="attr">"gt"</span>:<span class="number">20</span>,<span class="attr">"lt"</span>:<span class="number">200</span>&#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span>: [</span><br><span class="line">      &#123; <span class="attr">"price"</span>: &#123; <span class="attr">"order"</span>: <span class="string">"desc"</span> &#125;&#125;,</span><br><span class="line">      &#123; <span class="attr">"_score"</span>: &#123; <span class="attr">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-聚合aggregations"><a href="#4-聚合aggregations" class="headerlink" title="4. 聚合aggregations"></a>4. 聚合aggregations</h1><p>聚合可以让我们极其方便的实现对数据的统计、分析。例如：</p><ul><li>什么类型的书籍最受欢迎？</li><li>这些书的平均价格、最高价格、最低价格？</li><li>这些书每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现实时搜索效果。</p><h2 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h2><p>Elasticsearch中的聚合，包含多种类型，最常用的两种，一个叫<code>桶</code>，一个叫<code>度量</code>：</p><blockquote><p><strong>桶（bucket）</strong></p></blockquote><p>桶的作用，是按照某种方式对数据进行分组，每一组数据在ES中称为一个<code>桶</code>，例如根据国籍对人划分，可以得到<code>中国桶</code>、<code>英国桶</code>，<code>日本桶</code>……或者我们按照年龄段对人进行划分：0-10,10-20,20-30,30-40等。</p><p>Elasticsearch中提供的划分桶的方式有很多：</p><ul><li>Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组</li><li>Histogram Aggregation：根据数值阶梯分组，与日期类似</li><li>Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组</li><li>Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组</li><li>……</li></ul><p>综上所述，发现bucket aggregations 只负责对数据进行分组，并不进行计算，因此往往bucket中往往会嵌套另一种聚合：metrics aggregations即度量</p><blockquote><p><strong>度量（metrics）</strong></p></blockquote><p>分组完成以后，我们一般会对组中的数据进行聚合运算，例如求平均值、最大、最小、求和等，这些在ES中称为<code>度量</code></p><p>比较常用的一些度量聚合方式：</p><ul><li>Avg Aggregation：求平均值</li><li>Max Aggregation：求最大值</li><li>Min Aggregation：求最小值</li><li>Percentiles Aggregation：求百分比</li><li>Stats Aggregation：同时返回avg、max、min、sum、count等</li><li>Sum Aggregation：求和</li><li>Top hits Aggregation：求前几</li><li>Value Count Aggregation：求总数</li><li>……</li></ul><p>为了测试聚合，先批量导入一些数据</p><p>创建索引：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PUT /cars</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"number_of_shards"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"number_of_replicas"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"transactions"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"color"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"keyword"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"make"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"keyword"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在ES中，需要进行聚合、排序、过滤的字段其处理方式比较特殊，因此不能被分词。这里将color和make这两个文字类型的字段设置为keyword类型，这个类型不会被分词，将来就可以参与聚合</p><p>导入数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST /cars/transactions/_bulk</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"price"</span> : <span class="number">10000</span>, <span class="attr">"color"</span> : <span class="string">"red"</span>, <span class="attr">"make"</span> : <span class="string">"honda"</span>, <span class="attr">"sold"</span> : <span class="string">"2014-10-28"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"price"</span> : <span class="number">20000</span>, <span class="attr">"color"</span> : <span class="string">"red"</span>, <span class="attr">"make"</span> : <span class="string">"honda"</span>, <span class="attr">"sold"</span> : <span class="string">"2014-11-05"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"price"</span> : <span class="number">30000</span>, <span class="attr">"color"</span> : <span class="string">"green"</span>, <span class="attr">"make"</span> : <span class="string">"ford"</span>, <span class="attr">"sold"</span> : <span class="string">"2014-05-18"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"price"</span> : <span class="number">15000</span>, <span class="attr">"color"</span> : <span class="string">"blue"</span>, <span class="attr">"make"</span> : <span class="string">"toyota"</span>, <span class="attr">"sold"</span> : <span class="string">"2014-07-02"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"price"</span> : <span class="number">12000</span>, <span class="attr">"color"</span> : <span class="string">"green"</span>, <span class="attr">"make"</span> : <span class="string">"toyota"</span>, <span class="attr">"sold"</span> : <span class="string">"2014-08-19"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"price"</span> : <span class="number">20000</span>, <span class="attr">"color"</span> : <span class="string">"red"</span>, <span class="attr">"make"</span> : <span class="string">"honda"</span>, <span class="attr">"sold"</span> : <span class="string">"2014-11-05"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"price"</span> : <span class="number">80000</span>, <span class="attr">"color"</span> : <span class="string">"red"</span>, <span class="attr">"make"</span> : <span class="string">"bmw"</span>, <span class="attr">"sold"</span> : <span class="string">"2014-01-01"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"price"</span> : <span class="number">25000</span>, <span class="attr">"color"</span> : <span class="string">"blue"</span>, <span class="attr">"make"</span> : <span class="string">"ford"</span>, <span class="attr">"sold"</span> : <span class="string">"2014-02-12"</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-聚合为桶"><a href="#4-2-聚合为桶" class="headerlink" title="4.2 聚合为桶"></a>4.2 聚合为桶</h2><p>首先，我们按照 汽车的颜色<code>color</code>来划分<code>桶</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123; </span><br><span class="line">        <span class="attr">"popular_colors"</span> : &#123; </span><br><span class="line">            <span class="attr">"terms"</span> : &#123; </span><br><span class="line">              <span class="attr">"field"</span> : <span class="string">"color"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>size： 查询条数，这里设置为0，因为我们不关心搜索到的数据，只关心聚合结果，提高效率</li><li>aggs：声明这是一个聚合查询，是aggregations的缩写<ul><li>popular_colors：给这次聚合起一个名字，任意。<ul><li>terms：划分桶的方式，这里是根据词条划分<ul><li>field：划分桶的字段</li></ul></li></ul></li></ul></li></ul><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aggregations"</span>: &#123;</span><br><span class="line">    <span class="attr">"popular_colors"</span>: &#123;</span><br><span class="line">      <span class="attr">"doc_count_error_upper_bound"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"sum_other_doc_count"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"buckets"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"red"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">4</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"blue"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"green"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>hits：查询结果为空，因为我们设置了size为0</li><li>aggregations：聚合的结果</li><li>popular_colors：我们定义的聚合名称</li><li>buckets：查找到的桶，每个不同的color字段值都会形成一个桶<ul><li>key：这个桶对应的color字段的值</li><li>doc_count：这个桶中的文档数量</li></ul></li></ul><p>通过聚合的结果我们发现，目前红色的小车比较畅销！</p><h2 id="4-3-桶内度量"><a href="#4-3-桶内度量" class="headerlink" title="4.3 桶内度量"></a>4.3 桶内度量</h2><p>前面的例子告诉我们每个桶里面的文档数量，这很有用。 但通常，我们的应用需要提供更复杂的文档度量。 例如，每种颜色汽车的平均价格是多少？</p><p>因此，我们需要告诉Elasticsearch<code>使用哪个字段</code>，<code>使用何种度量方式</code>进行运算，这些信息要嵌套在<code>桶</code>内，<code>度量</code>的运算会基于<code>桶</code>内的文档进行</p><p>现在，我们为刚刚的聚合结果添加 求价格平均值的度量：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123; </span><br><span class="line">        <span class="attr">"popular_colors"</span> : &#123; </span><br><span class="line">            <span class="attr">"terms"</span> : &#123; </span><br><span class="line">              <span class="attr">"field"</span> : <span class="string">"color"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">                <span class="attr">"avg_price"</span>: &#123; </span><br><span class="line">                   <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                      <span class="attr">"field"</span>: <span class="string">"price"</span> </span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>aggs：我们在上一个aggs(popular_colors)中添加新的aggs。可见<code>度量</code>也是一个聚合,度量是在桶内的聚合</li><li>avg_price：聚合的名称</li><li>avg：度量的类型，这里是求平均值</li><li>field：度量运算的字段</li></ul><p>结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  "aggregations": &#123;</span><br><span class="line">    "popular_colors": &#123;</span><br><span class="line">      "doc_count_error_upper_bound": 0,</span><br><span class="line">      "sum_other_doc_count": 0,</span><br><span class="line">      "buckets": [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"red"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">32500</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"blue"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">20000</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"green"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">21000</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到每个桶中都有自己的<code>avg_price</code>字段，这是度量聚合的结果</p><h2 id="4-4-桶内嵌套桶"><a href="#4-4-桶内嵌套桶" class="headerlink" title="4.4 桶内嵌套桶"></a>4.4 桶内嵌套桶</h2><p>刚刚的案例中，我们在桶内嵌套度量运算。事实上桶不仅可以嵌套运算， 还可以再嵌套其它桶。也就是说在每个分组中，再分更多组。</p><p>比如：我们想统计每种颜色的汽车中，分别属于哪个制造商，按照<code>make</code>字段再进行分桶</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123; </span><br><span class="line">        <span class="attr">"popular_colors"</span> : &#123; </span><br><span class="line">            <span class="attr">"terms"</span> : &#123; </span><br><span class="line">              <span class="attr">"field"</span> : <span class="string">"color"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">                <span class="attr">"avg_price"</span>: &#123; </span><br><span class="line">                   <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                      <span class="attr">"field"</span>: <span class="string">"price"</span> </span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"maker"</span>:&#123;</span><br><span class="line">                    <span class="attr">"terms"</span>:&#123;</span><br><span class="line">                        <span class="attr">"field"</span>:<span class="string">"make"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原来的color桶和avg计算我们不变</li><li>maker：在嵌套的aggs下新添一个桶，叫做maker</li><li>terms：桶的划分类型依然是词条</li><li>filed：这里根据make字段进行划分</li></ul><p>部分结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;<span class="attr">"aggregations"</span>: &#123;</span><br><span class="line">    <span class="attr">"popular_colors"</span>: &#123;</span><br><span class="line">      <span class="attr">"doc_count_error_upper_bound"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"sum_other_doc_count"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"buckets"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"red"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="attr">"maker"</span>: &#123;</span><br><span class="line">            <span class="attr">"doc_count_error_upper_bound"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"sum_other_doc_count"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"buckets"</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">"key"</span>: <span class="string">"honda"</span>,</span><br><span class="line">                <span class="attr">"doc_count"</span>: <span class="number">3</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">"key"</span>: <span class="string">"bmw"</span>,</span><br><span class="line">                <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">32500</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"blue"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">"maker"</span>: &#123;</span><br><span class="line">            <span class="attr">"doc_count_error_upper_bound"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"sum_other_doc_count"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"buckets"</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">"key"</span>: <span class="string">"ford"</span>,</span><br><span class="line">                <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">"key"</span>: <span class="string">"toyota"</span>,</span><br><span class="line">                <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">20000</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"green"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">"maker"</span>: &#123;</span><br><span class="line">            <span class="attr">"doc_count_error_upper_bound"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"sum_other_doc_count"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"buckets"</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">"key"</span>: <span class="string">"ford"</span>,</span><br><span class="line">                <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">"key"</span>: <span class="string">"toyota"</span>,</span><br><span class="line">                <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">21000</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>我们可以看到，新的聚合<code>maker</code>被嵌套在原来每一个<code>color</code>的桶中。</li><li>每个颜色下面都根据 <code>make</code>字段进行了分组</li><li>我们能读取到的信息：<ul><li>红色车共有4辆</li><li>红色车的平均售价是 $32，500 美元。</li><li>其中3辆是 Honda 本田制造，1辆是 BMW 宝马制造。</li></ul></li></ul><h2 id="4-5-划分桶的其它方式"><a href="#4-5-划分桶的其它方式" class="headerlink" title="4.5.划分桶的其它方式"></a>4.5.划分桶的其它方式</h2><p>前面讲了，划分桶的方式有很多，例如：</p><ul><li>Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组</li><li>Histogram Aggregation：根据数值阶梯分组，与日期类似</li><li>Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组</li><li>Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组</li></ul><p>刚刚的案例中，我们采用的是Terms Aggregation，即根据词条划分桶。</p><p>接下来，我们再学习几个比较实用的：</p><h3 id="4-5-1-阶梯分桶Histogram"><a href="#4-5-1-阶梯分桶Histogram" class="headerlink" title="4.5.1.阶梯分桶Histogram"></a>4.5.1.阶梯分桶Histogram</h3><blockquote><p>原理：</p></blockquote><p>histogram是把数值类型的字段，按照一定的阶梯大小进行分组。你需要指定一个阶梯值（interval）来划分阶梯大小。</p><p>举例：</p><p>比如你有价格字段，如果你设定interval的值为200，那么阶梯就会是这样的：</p><p>0，200，400，600，…</p><p>上面列出的是每个阶梯的key，也是区间的启点。</p><p>如果一件商品的价格是450，会落入哪个阶梯区间呢？计算公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bucket_key = Math.floor((value - offset) / interval) * interval + offset</span><br></pre></td></tr></table></figure><p>value：就是当前数据的值，本例中是450</p><p>offset：起始偏移量，默认为0</p><p>interval：阶梯间隔，比如200</p><p>因此你得到的key = Math.floor((450 - 0) / 200) * 200 + 0 = 400</p><blockquote><p>操作一下：</p></blockquote><p>比如，我们对汽车的价格进行分组，指定间隔interval为5000：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">    <span class="attr">"price"</span>:&#123;</span><br><span class="line">      <span class="attr">"histogram"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"price"</span>,</span><br><span class="line">        <span class="attr">"interval"</span>: <span class="number">5000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">21</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aggregations"</span>: &#123;</span><br><span class="line">    <span class="attr">"price"</span>: &#123;</span><br><span class="line">      <span class="attr">"buckets"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">10000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">15000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">20000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">25000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">30000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">35000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">40000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">45000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">50000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">55000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">60000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">65000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">70000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">75000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">80000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现，中间有大量的文档数量为0 的桶，看起来很丑。</p><p>可以增加一个参数min_doc_count为1，来约束最少文档数量为1，这样文档数量为0的桶会被过滤</p><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">    <span class="attr">"price"</span>:&#123;</span><br><span class="line">      <span class="attr">"histogram"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"price"</span>,</span><br><span class="line">        <span class="attr">"interval"</span>: <span class="number">5000</span>,</span><br><span class="line">        <span class="attr">"min_doc_count"</span>: <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">15</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aggregations"</span>: &#123;</span><br><span class="line">    <span class="attr">"price"</span>: &#123;</span><br><span class="line">      <span class="attr">"buckets"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">10000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">15000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">20000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">25000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">30000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="number">80000</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你用kibana将结果变为柱形图，会更好看</p><h3 id="4-5-2-范围分桶range"><a href="#4-5-2-范围分桶range" class="headerlink" title="4.5.2.范围分桶range"></a>4.5.2.范围分桶range</h3><p>范围分桶与阶梯分桶类似，也是把数字按照阶段进行分组，只不过range方式需要你自己指定每一组的起始和结束大小。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 03 2019 14:07:43 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;大规模数据
      
    
    </summary>
    
      <category term="elasticsearch" scheme="http://yoursite.com/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="http://yoursite.com/tags/elasticsearch/"/>
    
      <category term="搜索引擎" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
</feed>
